













































Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics


Proceedings of the ACL 2007 Student Research Workshop, pages 49–54,
Prague, June 2007. c©2007 Association for Computational Linguistics

Logistic Online Learning Methods and Their Application to
Incremental Dependency Parsing

Richard Johansson

Department of Computer Science

Lund University

Lund, Sweden

richard@cs.lth.se

Abstract

We investigate a family of update methods

for online machine learning algorithms for

cost-sensitive multiclass and structured clas-

sification problems. The update rules are

based on multinomial logistic models. The

most interesting question for such an ap-

proach is how to integrate the cost function

into the learning paradigm. We propose a

number of solutions to this problem.

To demonstrate the applicability of the al-

gorithms, we evaluated them on a number

of classification tasks related to incremental

dependency parsing. These tasks were con-

ventional multiclass classification, hiearchi-

cal classification, and a structured classifica-

tion task: complete labeled dependency tree

prediction. The performance figures of the

logistic algorithms range from slightly lower

to slightly higher than margin-based online

algorithms.

1 Introduction

Natural language consists of complex structures,

such as sequences of phonemes, parse trees, and dis-

course or temporal graphs. Researchers in NLP have

started to realize that this complexity should be re-

flected in their statistical models. This intuition has

spurred a growing interest of related research in the

machine learning community, which in turn has led

to improved results in a wide range of applications

in NLP, including sequence labeling (Lafferty et al.,

2001; Taskar et al., 2006), constituent and depen-

dency parsing (Collins and Duffy, 2002; McDon-

ald et al., 2005), and logical form extraction (Zettle-

moyer and Collins, 2005).

Machine learning research for structured prob-

lems have generally used margin-based formula-

tions. These include global batch methods such as

Max-margin Markov Networks (M3N) (Taskar et al.,

2006) and SVMstruct (Tsochantaridis et al., 2005)

as well as online methods such as Margin Infused

Relaxed Algorithm (MIRA) (Crammer and Singer,

2003) and the Online Passive-Aggressive Algorithm

(OPA) (Crammer et al., 2006). Although the batch

methods are formulated very elegantly, they do not

seem to scale well to the large training sets prevalent

in NLP contexts. The online methods on the other

hand, although less theoretically appealing, can han-

dle realistically sized data sets.

In this work, we investigate whether logistic

online learning performs as well as margin-based

methods. Logistic models are easily extended to us-

ing kernels; that this is theoretically well-justified

was shown by Zhu and Hastie (2005), who also

made an elegant argument that margin-based meth-

ods are in fact related to regularized logistic models.

For batch learning, there exist several learning algo-

rithms in a logistic framework for conventional mul-

ticlass classification but few for structured problems.

Prediction of complex structures is conventionally

treated as a cost-sensitive multiclass classification

problem, although special care has to be taken to

handle the large space of possible outputs. The in-

tegration of the cost function into the logistic frame-

work leads to two distinct (although related) update

methods: the Scaled Prior Variance (SPV) and the

Minimum Expected Cost (MEC) updates.

Apart from its use in structured prediction, cost-

sensitive classification is useful for hierachical clas-

sification, which we briefly consider here in an ex-

periment. This type of classification has useful ap-

49



plications in NLP. Apart from the obvious use in

classification of concepts in an ontology, it is also

useful for prediction of complex morphological or

named-entity tags. Cost-sensitive learning is also

required in the SEARN algorithm (Daumé III et al.,

2006), which is a method to decompose the predic-

tion problem of a complex structure into a sequence

of actions, and train the search in the space of action

sequences to maximize global performance.

2 Algorithm

Wemodel the learning problem as finding a discrim-

inant function F that assigns a score to each possible

output y given an input x. Classification in this set-

ting is done by finding the ŷ that maximizes F (x, y).
In this work, we consider linear discriminants of the

following form:

F (x, y) = 〈w,Ψ(x, y)〉

Here,Ψ(x, y) is a numeric feature representation of
the pair (x, y) and w a vector of feature weights.
Learning in this case is equivalent to assigning ap-

propriate weights in the vector w.

In the online learning framework, the weight vec-

tor is constructed incrementally. Algorithm 1 shows

the general form of the algorithm. It proceeds a

number of times through the training set. In each

step, it computes an update to the weight vector

based on the current example. The resulting weight

vector tends to be overfit to the last few examples;

one way to reduce overfitting is to use the average

of all successive weight vectors as the result of the

training (Freund and Schapire, 1999).

Algorithm 1 General form of online algorithms

input Training set T = {(xt, yt)}
T
t=1

Number of iterations N

for n in 1..N
for (xt, yt) in T
Compute update vector δw for (xt, yt)
w ← w + δw

return waverage

Following earlier online learning methods such as

the Perceptron, we assume that in each update step,

we adjust the weight vector by incrementally adding

feature vectors. For stability, we impose the con-

straint that the sum of the updates in each step should

be zero. We assume that the possible output values

are {yi}
m
i=0 and, for convenience, that y0 is the cor-

rect value. This leads to the following ansatz:

δw =

m∑

j=1

αj(Ψ(x, y0)−Ψ(x, yj))

Here, αj defines how much F is shifted to favor y0
instead of yj . This is also the approach (implicitly)

used by other algorithms such as MIRA and OPA.

The following two subsections present two ways

of creating the weight update δw, differing in how

the cost function is integrated into the model. Both

are based on a multinomial logistic framework,

where we model the probability of the class y being

assigned to an input x using a “soft-max” function

as follows:

P (y|x) =
eF (x,y)

∑m
j=0 e

F (x,yj)

2.1 Scaled Prior Variance Approach

The first update method, Scaled Prior Variance

(SPV), directly uses the probability of the correct

output. It uses a maximum a posteriori approach,

where the cost function is used by the prior.

Naïvely, the update could be done by maximizing

the likelihood with respect to α in each step. How-

ever, this would lead to overfitting – in the case of

separability, a maximum does not even exist. We

thus introduce a regularizing prior that penalizes

large values ofα. We introduce variance-controlling

hyperparameters sj for each αj , and with a Gaussian

prior we obtain (disregarding constants) the follow-

ing log posterior:

L(α) =
m∑

j=1

αj(K00 −Kj0)−
m∑

j=1

sjα
2
j

− log
m∑

k=0

e
fk+

P

m
j=1

αj(K0k−Kjk)

where Kij = 〈Ψ(x, yi),Ψ(x, yj)〉 and fk =
F (x, yk) (i.e. the output before w is updated).
As usual, the feature vectors occur only in inner

products, allowing us to use kernels if appropriate.

50



We could have used any prior; however, in prac-

tice we will require it to be log-concave to avoid

suboptimal local maxima. A Laplacian prior (i.e.

−
∑m

j=1 sj|αj |) will also be considered in this work
– the discontinuity of its gradient at the origin seems

to pose no problem in practice.

Costs are incorporated into the model by as-

sociating them to the prior variances. We tried

two variants of variance scaling. In the first case,

we let the variance be directly proportional to the

cost (C-SPV):

sj =
γ

c(yj)

where γ is a tradeoff parameter controlling the rel-

ative weight of the prior with respect to the likeli-

hood. Intuitively, this model allows the algorithm

more freedom to adjust an αj associated with a yj
with a high cost.

In the second case, inspired by margin-based

learning we instead scaled the variance by the loss,

i.e. the scoring error plus the cost (L-SPV):

sj =
γ

max(0, fj − f0) + c(yj)

Here, the intuition is instead that the algorithm is

allowed more freedom for “dangerous” outputs that

are ranked high but have high costs.

2.2 Minimum Expected Cost Approach

In the second approach to integrating the cost func-

tion, the Minimum Expected Cost (MEC) update,

the method seeks to minimize the expected cost in

each step. Once again using the soft-max probabil-

ity, we get the following expectation of the cost:

E(c(y)|x) =
m∑

k=0

c(yk)P (yk|x)

=

∑m
k=0 c(yk)e

fk+
Pm

j=1
αj(K0k−Kjk)

∑m
k=0 e

fk+
P

m
j=1

αj(K0k−Kjk)

This quantity is easily minimized in the same way

as the SPV posterior was maximized, although

we had to add a constant 1 to the expectation to
avoid numerical instability. To avoid overfitting, we

added a quadratic regularizer γ
∑m

j=1 α
2
j to log(1 +

E(c(y)|x)) just like the prior in the SPV method,

although this regularizer does not have an interpre-

tation as a prior.

The MEC update is closely related to SPV: for

cost-insensitive classification (i.e. the cost of every

misclassified instance is 1), the expectation is equal
to one minus the likelihood in the SPV model.

2.3 Handling Complex Prediction Problems

The algorithm can thus be used for any cost-

sensitive classification problem. This class of prob-

lems includes prediction of complex structures such

as trees or graphs. However, for those problems the

set of possible outputs is typically very large. Two

broad categories of solutions to this problem have

been common in literature, both of which rely on

the structure of the domain:

• Subset selection: instead of working with the
complete range of outputs, only an “interest-

ing” subset is used, for instance by repeatedly

finding the most violated constraints (Tsochan-

taridis et al., 2005) or by using N -best search

(McDonald et al., 2005).

• Decomposition: the inherent structure of the
problem is used to factorize the optimiza-

tion problem. Examples include Markov de-

compositions in M3N (Taskar et al., 2006)

and dependency-based factorization for MIRA

(McDonald et al., 2005).

In principle, both methods could be used in our

framework. In this work, we use subset selec-

tion since it is easy to implement for many do-

mains (in the form of an N -best search) and al-

lows a looser coupling between the domain and the

learning algorithm.

2.4 Implementation Issues

Since we typically work with only a few variables in

each iteration, maximizing the log posterior or mini-

mizing the expectation is easy (assuming, of course,

that we chose a log-concave prior). We used gra-

dient ascent and did not try to use more sophisti-

cated optimization procedures like BFGS or New-

ton’s method. Typically, only a few iterations were

needed to reach the optimum. The running time of

the update step is almost identical to that of MIRA,

which solves a small quadratic program in each step,

but longer than for the Perceptron algorithm or OPA.

51



Actions Parser actions Conditions

Initialize (nil,W, ∅)
Terminate (S, nil, A)
Left-arc (n|S, n′|I,A)→ (S, n′|I,A ∪ {(n′, n)}) ¬∃n′′(n′′, n) ∈ A
Right-arc (n|S, n′|I,A)→ (n′|n|S, I,A ∪ {(n, n′)}) ¬∃n′′(n′′, n′) ∈ A
Reduce (n|S, I,A)→ (S, I,A) ∃n′(n′, n) ∈ A
Shift (S, n|I,A)→ (n|S, I,A)

Table 1: Nivre’s parser transitions where W is the initial word list; I , the current input word list; A, the

graph of dependencies; and S, the stack. (n′, n) denotes a dependency relations between n′ and n, where n′

is the head and n the dependent.

3 Experiments

To compare the logistic online algorithms against

other learning algorithms, we performed a set of ex-

periments in incremental dependency parsing using

the Nivre algorithm (Nivre, 2003).

The algorithm is a variant of the shift–reduce al-

gorithm and creates a projective and acyclic graph.

As with the regular shift–reduce, it uses a stack S

and a list of input words W , and builds the parse

tree incrementally using a set of parsing actions (see

Table 1). However, instead of finding constituents,

it builds a set of arcs representing the graph of de-

pendencies. It can be shown that every projective

dependency graph can be produced by a sequence

of parser actions, and that the worst-case number of

actions is linear with respect to the number of words

in the sentence.

3.1 Multiclass Classification

In the first experiment, we trained multiclass clas-

sifiers to choose an action in a given parser state

(see (Nivre, 2003) for a description of the feature

set). We stress that this is true multiclass classifica-

tion rather than a decomposed method (such as one-

versus-all or pairwise binarization).

As a training set, we randomly selected 50,000

instances of state–action pairs generated for a

dependency-converted version of Penn Treebank.

This training set contained 22 types of actions (such

as SHIFT, REDUCE, LEFT-ARC(SUBJECT), and

RIGHT-ARC(OBJECT). The test set was also ran-

domly selected and contained 10,000 instances.

We trained classifiers using the logistic updates

(C-SPV, L-SPV, and MEC) with Gaussian and

Laplacian priors. Additionally, we trained OPA

and MIRA classifiers, as well as an Additive Ultra-

conservative (AU) classifier (Crammer and Singer,

2003), a variant of the Perceptron.

For all algorithms, we tried to find the best val-

ues of the respective regularization parameter using

cross-validation. All training algorithms iterated five

times through the training set and used an expanded

quadratic kernel.

Table 2 shows the classification error for all algo-

rithms. As can be seen, the performance was lower

for the logistic algorithms, although the difference

was slight. Both the logistic (MEC and SPV) and

the margin-based classifiers (OPA and MIRA) out-

performed the AU classifier.

Method Test error

MIRA 6.05%
OPA 6.17%
C-SPV, Laplace 6.20%
MEC, Laplace 6.21%
C-SPV, Gauss 6.22%
MEC, Gauss 6.23%
L-SPV, Laplace 6.25%
L-SPV, Gauss 6.26%
AU 6.39%

Table 2: Multiclass classification results.

3.2 Hierarchical Classification

In the second experiment, we used the same train-

ing and test set, but considered the selection of the

parsing action as a hierarchical classficiation task,

i.e. the predicted value has a main type (SHIFT,

REDUCE, LEFT-ARC, and RIGHT-ARC) and possi-

bly also a subtype (such as LEFT-ARC(SUBJECT) or

52



RIGHT-ARC(OBJECT)).

To predict the class in this experiment, we used

the same feature function but a new cost function:

the cost of misclassification was 1 for an incorrect
parsing action, and 0.5 if the action was correct but
the arc label incorrect.

We used the same experimental setup as in the

multiclass experiment. Table 3 shows the average

cost on the test set for all algorithms. Here, the

MEC update outperformed the margin-based ones

by a negligible difference. We did not use AU in

this experiment since it does not optimize for cost.

Method Average cost

MEC, Gauss 0.0573
MEC, Laplace 0.0576
OPA 0.0577
C-SPV, Gauss 0.0582
C-SPV, Laplace 0.0587
MIRA 0.0590
L-SPV, Gauss 0.0590
L-SPV, Laplace 0.0632

Table 3: Hierarchical classification results.

3.3 Prediction of Complex Structures

Finally, we made an experiment in prediction of de-

pendency trees. We created a global model where

the discriminant function was trained to assign high

scores to the correct parse tree. A similar model was

previously used by McDonald et al. (2005), with the

difference that we here represent the parse tree as

a sequence of actions in the incremental algorithm

rather than using the dependency links directly.

For a sentence x and a parse tree y, we defined

the feature representation by finding the sequence

((S1, I1) , a1) , ((S2, I2) , a2) . . . of states and their
corresponding actions, and creating a feature vector

for each state/action pair. The discriminant function

was thus written

〈Ψ(x, y),w〉 =
∑

i

〈ψ((Si, Ii) , ai),w〉

where ψ is the feature function from the previous

two experiments, which assigns a feature vector to a

state (Si, Ii) and the action ai taken in that state.

The cost function was defined as the sum of link

costs, where the link cost was 0 for a correct depen-
dency link with a correct label, 0.5 for a correct link
with an incorrect label, and 1 for an incorrect link.
Since the history-based feature set used in the

parsing algorithm makes it impossible to use inde-

pendence to factorize the scoring function, an exact

search to find the best-scoring action sequence is not

possible. We used a beam search of width 2 in this
experiment.

We trained models on a 5000-word subset of the

Basque Treebank (Aduriz et al., 2003) and evalu-

ated them on a 8000-word subset of the same cor-

pus. As before, we used an expanded quadratic ker-

nel, and all algorithms iterated five times through the

training set.

Table 4 shows the results of this experiment. We

show labeled accuracy instead of cost for ease of in-

terpretation. Here, the loss-based SPV outperformed

Method Labeled Accuracy

L-SPV, Gauss 66.24
MIRA 66.19
MEC, Gauss 65.99
C-SPV, Gauss 65.84
OPA 65.45
MEC, Laplace 64.81
C-SPV, Laplace 64.73
L-SPV, Laplace 64.50

Table 4: Results for dependency tree prediction.

MIRA, and two other logistic updates also outper-

formed OPA. The differences between the first four

scores are however not statistically significant. In-

terestingly, all updates with Laplacian prior resulted

in low performance. The reason for this may be that

Laplacian priors tend to promote sparse solutions

(see Krishnapuram et al. (2005), inter alia), and that

this sparsity is detrimental for this highly lexicalized

feature set.

4 Conclusion and Future Work

This paper presented new update methods for online

machine learning algorithms. The update methods

are based on a multinomial logistic model. Their

performance is on par with other state-of-the-art on-

line learning algorithms for cost-sensitive problems.

53



We investigated two main approaches to integrat-

ing the cost function into the logistic model. In the

first method, the cost was linked to the prior vari-

ances, while in the second method, the update rule

sets the weights to minimize the expected cost. We

tried a few different priors. Which update method

and which prior was the best varied between exper-

iments. For instance, the update where the prior

variances were scaled by the costs was the best-

performing in the multiclass experiment but the

worst-performing in the dependency tree prediction

experiment.

In the SPV update, the cost was incorporated into

the MAP model in a rather ad-hoc fashion. Al-

though this seems to work well, we would like to

investigate this further and possibly devise a cost-

based prior that is both theoretically well-grounded

and performs well in practice.

To achieve a good classification performance us-

ing the updates presented in this article, there is a

considerable need for cross-validation to find the

best value for the regularization parameter. This is

true for most other classification methods as well,

including SVM, MIRA, and OPA. There has been

some work on machine learning methods where this

parameter is tuned automatically (Tipping, 2001),

and a possible extension to our work could be to

adapt those models to the multinomial and cost-

sensitive setting.

We applied the learning models to three problems

in incremental dependency parsing, the last of which

being prediction of full labeled dependency trees.

Our system can be seen as a unification of the two

best-performing parsers presented at the CoNLL-X

Shared Task (Buchholz and Marsi, 2006).

References

Itzair Aduriz, Maria Jesus Aranzabe, Jose Mari Arriola,
Aitziber Atutxa, Arantza Diaz de Ilarraza, Aitzpea
Garmendia, and Maite Oronoz. 2003. Construction
of a Basque dependency treebank. In Proceedings of
the TLT, pages 201–204.

Sabine Buchholz and Erwin Marsi. 2006. CoNLL-X
shared task on multilingual dependency parsing. In
Proceedings of the CoNLL-X.

Michael Collins and Nigel Duffy. 2002. New ranking
algorithms for parsing and tagging: Kernels over dis-

crete structures, and the voted perceptron. In Proceed-
ings of the ACL.

Koby Crammer and Yoram Singer. 2003. Ultraconserva-
tive online algorithms for multiclass problems. Jour-
nal of Machine Learning Research, 2003(3):951–991.

Koby Crammer, Ofer Dekel, Joseph Keshet, Shai Shalev-
Schwartz, and Yoram Singer. 2006. Online passive-
aggressive algorithms. Journal of Machine Learning
Research, 2006(7):551–585.

Hal Daumé III, John Langford, and Daniel Marcu. 2006.
Search-based structured prediction. Submitted.

Yoav Freund and Robert E. Schapire. 1999. Large mar-
gin classification using the perceptron algorithm. Ma-
chine Learning, 37(3):277–296.

Balaji Krishnapuram, Lawrence Carin, Mário A. T.
Figueiredo, and Alexander J. Hartemink. 2005.
Sparse multinomial logistic regression: Fast algo-
rithms and generalization bounds. IEEE Transactions
on Pattern Analysis and Machine Intelligence, 27(6).

John Lafferty, AndrewMcCallum, and Fernando Pereira.
2001. Conditional random fields: Probabilistic mod-
els for segmenting and labeling sequence data. In Pro-
ceedings of the 18th International Conference on Ma-
chine Learning.

Ryan McDonald, Fernando Pereira, Kiril Ribarov, and
Jan Hajič. 2005. Non-projective dependency pars-
ing using spanning tree algorithms. In Proceedings
of HLT-EMNLP-2005.

Joakim Nivre. 2003. An efficient algorithm for projec-
tive dependency parsing. In Proceedings of the 8th In-
ternational Workshop on Parsing Technologies (IWPT
03), pages 149–160, Nancy, France, 23-25 April.

Ben Taskar, Carlos Guestrin, Vassil Chatalbashev, and
Daphne Koller. 2006. Max-margin Markov networks.
Journal of Machine Learning Research, to appear.

Michael E. Tipping. 2001. Sparse Bayesian learning
and the relevance vector machine. Journal of Machine
Learning Research, 1:211 – 244.

Iannis Tsochantaridis, Thorsten Joachims, Thomas Hof-
mann, and Yasemin Altun. 2005. Large margin meth-
ods for structured and interdependent output variables.
Journal of Machine Learning Research, 6(Sep):1453–
1484.

Luke S. Zettlemoyer and Michael Collins. 2005. Learn-
ing to map sentences to logical form: Structured clas-
sification with probabilistic categorial grammars. In
Proceedings of UAI 2005.

Ji Zhu and Trevor Hastie. 2005. Kernel logistic regres-
sion and the import vector machine. Journal of Com-
putational and Graphical Statistics, 14(1):185–205.

54


