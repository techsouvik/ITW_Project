













































Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics


Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics, pages 384–391,
Prague, Czech Republic, June 2007. c©2007 Association for Computational Linguistics

Fast Unsupervised Incremental Parsing

Yoav Seginer
Institute for Logic, Language and Computation

Universiteit van Amsterdam
Plantage Muidergracht 24

1018TV Amsterdam
The Netherlands

yseginer@science.uva.nl

Abstract

This paper describes an incremental parser
and an unsupervised learning algorithm for
inducing this parser from plain text. The
parser uses a representation for syntactic
structure similar to dependency links which
is well-suited for incremental parsing. In
contrast to previous unsupervised parsers,
the parser does not use part-of-speech tags
and both learning and parsing are local
and fast, requiring no explicit clustering or
global optimization. The parser is evalu-
ated by converting its output into equivalent
bracketing and improves on previously pub-
lished results for unsupervised parsing from
plain text.

1 Introduction

Grammar induction, the learning of the grammar
of a language from unannotated example sentences,
has long been of interest to linguists because of its
relevance to language acquisition by children. In
recent years, interest in unsupervised learning of
grammar has also increased among computational
linguists, as the difficulty and cost of constructing
annotated corpora led researchers to look for ways
to train parsers on unannotated text. This can ei-
ther be semi-supervised parsing, using both anno-
tated and unannotated data (McClosky et al., 2006)
or unsupervised parsing, training entirely on unan-
notated text.

The past few years have seen considerable im-
provement in the performance of unsupervised

parsers (Klein and Manning, 2002; Klein and Man-
ning, 2004; Bod, 2006a; Bod, 2006b) and, for the
first time, unsupervised parsers have been able to
improve on the right-branching heuristic for pars-
ing English. All these parsers learn and parse
from sequences of part-of-speech tags and select,
for each sentence, the binary parse tree which maxi-
mizes some objective function. Learning is based on
global maximization of this objective function over
the whole corpus.

In this paper I present an unsupervised parser
from plain text which does not use parts-of-speech.
Learning is local and parsing is (locally) greedy. As
a result, both learning and parsing are fast. The
parser is incremental, using a new link representa-
tion for syntactic structure. Incremental parsing was
chosen because it considerably restricts the search
space for both learning and parsing. The represen-
tation the parser uses is designed for incremental
parsing and allows a prefix of an utterance to be
parsed before the full utterance has been read (see
section 3). The representation the parser outputs can
be converted into bracketing, thus allowing evalua-
tion of the parser on standard treebanks.

To achieve completely unsupervised parsing,
standard unsupervised parsers, working from part-
of-speech sequences, need first to induce the parts-
of-speech for the plain text they need to parse. There
are several algorithms for doing so (Schütze, 1995;
Clark, 2000), which cluster words into classes based
on the most frequent neighbors of each word. This
step becomes superfluous in the algorithm I present
here: the algorithm collects lists of labels for each
word, based on neighboring words, and then directly

384



uses these labels to parse. No clustering is per-
formed, but due to the Zipfian distribution of words,
high frequency words dominate these lists and pars-
ing decisions for words of similar distribution are
guided by the same labels.

Section 2 describes the syntactic representation
used, section 3 describes the general parser algo-
rithm and sections 4 and 5 complete the details by
describing the learning algorithm, the lexicon it con-
structs and the way the parser uses this lexicon. Sec-
tion 6 gives experimental results.

2 Common Cover Links

The representation of syntactic structure which I in-
troduce in this paper is based on links between pairs
of words. Given an utterance and a bracketing of
that utterance, shortest common cover link sets for
the bracketing are defined. The original bracketing
can be reconstructed from any of these link sets.

2.1 Basic Definitions

An utterance is a sequence of words 〈x1, . . . , xn〉
and a bracket is any sub-sequence 〈xi, . . . , xj〉 of
consecutive words in the utterance. A set B of brack-
ets over an utterance U is a bracketing of U if every
word in U is in some bracket and for any X,Y ∈ B
either X ∩ Y = ∅, X ⊆ Y or Y ⊆ X (non-
crossing brackets). The depth of a word x ∈ U
under a bracket B ∈ B (x ∈ B) is the maxi-
mal number of brackets X1, . . . , Xn ∈ B such that
x ∈ X1 ⊂ . . . ⊂ Xn ⊂ B. A word x is a generator
of depth d of B in B if x is of minimal depth under
B (among all words in B) and that depth is d. A
bracket may have more than one generator.

2.2 Common Cover Link Sets

A common cover link over an utterance U is a triple

x
d
→ y where x, y ∈ U , x 6= y and d is a non-

negative integer. The word x is the base of the link,
the word y is its head and d is the depth of the link.
The common cover link set RB associated with a
bracketing B is the set of common cover links over

U such that x
d
→ y ∈ RB iff the word x is a gener-

ator of depth d of the smallest bracket B ∈ B such
that x, y ∈ B (see figure 1(a)).

Given RB, a simple algorithm reconstructs the
bracketing B: for each word x and depth 0 ≤ d,

(a) [ [ w ]

1

;;

1

<<

1

==[ x

1
zz

0
!!

0

  
[ y //0 z ] ] ]oo

(b) [ [ w ] [ x

1
zz

0
!!

0

  
[ y //0 z ] ] ]oo

(c) [ [ w ] [ x

1
zz

0
!!

[ y //0 z ] ] ]oo

Figure 1: (a) The common cover link set RB of a
bracketing B, (b) a representative subset R of RB,
(c) the shortest common cover link set based on R.

create a bracket covering x and all y such that for

some d′ ≤ d, x
d′
→ y ∈ RB.

Some of the links in the common cover link set
RB are redundant. The first redundancy is the result
of brackets having more than one generator. The
bracketing reconstruction algorithm outlined above
can construct a bracket from the links based at any
of its generators. The bracketing B can therefore be
reconstructed from a subset R ⊆ RB if, for every
bracket B ∈ B, R contains the links based at least at
one generator1 of B. Such a set R is a representative
subset of RB (see figure 1(b)).

A second redundancy in the set RB follows from
the linear transitivity of RB:

Lemma 1 If y is between x and z, x
d1
→ y ∈ RB and

y
d2
→ z ∈ RB then x

d
→ z ∈ RB where if there is a

link y
d′
→ x ∈ RB then d = max(d1, d2) and d = d1

otherwise.

This property implies that longer links can be de-
duced from shorter links. It is, therefore, sufficient
to leave only the shortest necessary links in the set.
Given a representative subset R of RB, a shortest
common cover link set of RB is constructed by re-
moving any link which can be deduced from shorter
links by linear transitivity. For each representative
subset R ⊆ RB, this defines a unique shortest com-
mon cover link set (see figure 1(c)).

Given a shortest common cover link set S, the
bracketing which it represents can be calculated by

1From the bracket reconstruction algorithm it can be seen
that links of depth 0 may never be dropped.

385



[ [ I ] [ know
{{ %%

[ [ the boy ]oo [ sleeps ] ] ] ]
}}

(a) dependency structure

[ [ I ] [ know
1

{{

0

%%
0

""
[ [ the

0 // boy ]oo [ sleeps ] ] ] ]
1

}}

(b) shortest common cover link set

Figure 2: A dependency structure and shortest com-
mon cover link set of the same sentence.

first using linear transitivity to deduce missing links
and then applying the bracket reconstruction algo-
rithm outlined above for RB.

2.3 Comparison with Dependency Structures

Having defined a link-based representation of syn-
tactic structure, it is natural to wonder what the rela-
tion is between this representation and standard de-
pendency structures. The main differences between
the two representations can all be seen in figure 2.
The first difference is in the linking of the NP the
boy. While the shortest common cover link set has
an exocentric construction for this NP (that is, links
going back and forth between the two words), the
dependency structure forces us to decide which of
the two words in the NP is its head. Considering
that linguists have not been able to agree whether it
is the determiner or the noun that is the head of an
NP, it may be easier for a learning algorithm if it did
not have to make such a choice.

The second difference between the structures can
be seen in the link from know to sleeps. In the short-
est common cover link set, there is a path of links
connecting know to each of the words separating it
from sleeps, while in the dependency structure no
such links exist. This property, which I will refer to
as adjacency plays an important role in incremental
parsing, as explained in the next section.

The last main difference between the represen-
tations is the assignment of depth to the common
cover links. In the present example, this allows us to
distinguish between the attachment of the external
(subject) and the internal (object) arguments of the
verb. Dependencies cannot capture this difference
without additional labeling of the links. In what fol-
lows, I will restrict common cover links to having

depth 0 or 1. This restriction means that any tree
represented by a shortest common cover link set will
be skewed - every subtree must have a short branch.
It seems that this is indeed a property of the syntax
of natural languages. Building this restriction into
the syntactic representation considerably reduces the
search space for both parsing and learning.

3 Incremental Parsing

To calculate a shortest common cover link for an
utterance, I will use an incremental parser. Incre-
mentality means that the parser reads the words of
the utterance one by one and, as each word is read,
the parser is only allowed to add links which have
one of their ends at that word. Words which have
not yet been read are not available to the parser at
this stage. This restriction is inspired by psycholin-
guistic research which suggests that humans process
language incrementally (Crocker et al., 2000). If the
incrementality of the parser roughly resembles that
of human processing, the result is a significant re-
striction of parser search space which does not lead
to too many parsing errors.

The adjacency property described in the previous
section makes shortest common cover link sets es-
pecially suitable for incremental parsing. Consider
the example given in figure 2. When the word the
is read, the parser can already construct a link from
know to the without worrying about the continuation
of the sentence. This link is part of the correct parse
whether the sentence turns out to be I know the boy
or I know the boy sleeps. A dependency parser, on
the other hand, cannot make such a decision before
the end of the sentence is reached. If the sentence is
I know the boy then a dependency link has to be cre-
ated from know to boy while if the sentence is I know
the boy sleeps then such a link is wrong. This prob-
lem is known in psycholinguistics as the problem of
reanalysis (Sturt and Crocker, 1996).

Assume the incremental parser is processing a
prefix 〈x1, . . . , xk〉 of an utterance and has already
deduced a set of links L for this prefix. It can now
only add links which have one of their ends at xk and
it may never remove any links. From the definitions
in section 2.2 it is possible to derive an exact char-
acterization of the links which may be added at each
step such that the resulting link set represents some

386



bracketing. It can be shown that any shortest com-
mon cover link set can be constructed incrementally
under these conditions. As the full specification of
these conditions is beyond the scope of this paper, I
will only give the main condition, which is based on
adjacency. It states that a link may be added from x
to y only if for every z between x and y there is a
path of links (in L) from x to z but no link from z to
y. In the example in figure 2 this means that when
the word sleeps is first read, a link to sleeps can be
created from know, the and boy but not from I.

Given these conditions, the parsing process is
simple. At each step, the parser calculates a non-
negative weight (section 5) for every link which
may be added between the prefix 〈x1, . . . , xk−1〉 and
xk. It then adds the link with the strongest positive
weight and repeats the process (adding a link can
change the set of links which may be added). When
all possible links are assigned a zero weight by the
parser, the parser reads the next word of the utter-
ance and repeats the process. This is a greedy algo-
rithm which optimizes every step separately.

4 Learning

The weight function which assigns a weight to a can-
didate link is lexicalized: the weight is calculated
based on the lexical entries of the words which are
to be connected by the link. It is the task of the learn-
ing algorithm to learn the lexicon.

4.1 The Lexicon

The lexicon stores for each word x a lexical en-
try. Each such lexical entry is a sequence of adja-
cency points, holding statistics relevant to the deci-
sion whether to link x to some other word. These
statistics are given as weights assigned to labels and
linking properties. Each adjacency point describes a
different link based at x, similar to the specification
of the arguments of a word in dependency parsing.

Let W be the set of words in the corpus. The
set of labels L(W ) = W × {0, 1} consists of
two labels based on every word w: a class la-
bel (w, 0) (denoted by [w]) and an adjacency la-
bel (w, 1) (denoted by [w ] or [ w]). The two la-
bels (w, 0) and (w, 1) are said to be opposite la-
bels and, for l ∈ L(W ), I write l−1 for the op-
posite of l. In addition to the labels, there is also

a finite set P = {Stop, In∗, In,Out} of link-
ing properties. The Stop specifies the strength of
non-attachment, In and Out specify the strength
of inbound and outbound links and In∗ is an in-
termediate value in the induction of inbound and
outbound strengths. A lexicon L is a function
which assigns each word w ∈ W a lexical entry
(. . . , Aw−2, A

w
−1, A

w
1 , A

w
2 , . . .). Each of the A

w
i is an

adjacency point.
Each Awi is a function A

w
i : L(W ) ∪ P → R

which assigns each label in L(W ) and each linking
property in P a real valued strength. For each Awi ,
#(Awi ) is the count of the adjacency point: the num-
ber of times the adjacency point was updated. Based
on this count, I also define a normalized version of
Awi : Ā

w
i (l) = A

w
i (l)/#(A

w
i ).

4.2 The Learning Process

Given a sequence of training utterances (Ut)0≤t, the
learner constructs a sequence of lexicons (Ls)0≤s
beginning with the zero lexicon L0 (which assigns
a zero strength to all labels and linking properties).
At each step, the learner uses the parsing function
PLs based on the previously learned lexicon Ls to
extend the parse L of an utterance Ut. It then uses
the result of this parse step (together with the lexi-
con Ls) to create a new lexicon Ls+1 (it may be that
Ls = Ls+1). This operation is a lexicon update. The
process then continues with the new lexicon Ls+1.
Any of the lexicons Ls constructed by the learner
may be used for parsing any utterance U , but as s
increases, parsing accuracy should improve. This
learning process is open-ended: additional training
text can always be added without having to re-run
the learner on previous training data.

4.3 Lexicon Update

To define a lexicon update, I extend the definition of
an utterance to be U = 〈∅l, x1, . . . , xn, ∅r〉 where ∅l
and ∅r are boundary markers. The property of adja-
cency can now be extended to include the boundary
markers. A symbol α ∈ U is adjacent to a word x
relative to a set of links L over U if for every word z
between x and α there is a path of links in L from x
to z but there is no link from z to α. In the following
example, the adjacencies of x1 are ∅l, x2 and x3:

x1 0 // x2 x3 x4

387



If a link is added from x2 to x3, x4 becomes adjacent
to x1 instead of x3 (the adjacencies of x1 are then ∅l,
x2 and x4):

x1 0 // x2 0 // x3 x4

The positions in the utterance adjacent to a word x
are indexed by an index i such that i < 0 to the left
of x, i > 0 to the right of x and |i| increases with the
distance from x.

The parser may only add a link from a word x to
a word y adjacent to x (relative to the set of links al-
ready constructed). Therefore, the lexical entry of x
should collect statistics about each of the adjacency
positions of x. As seen above, adjacency positions
may move, so the learner waits until the parser com-
pletes parsing the utterance and then updates each
adjacency point Axi with the symbol α at the ith ad-
jacency position of x (relative to the parse generated
by the parser). It should be stressed that this update
does not depend on whether a link was created from
x to α. In particular, whatever links the parser as-
signs, Ax

(−1)
and Ax1 are always updated by the sym-

bols which appear immediately before and after x.
The following example should clarify the picture.

Consider the fragment:

put 0 // the //0 boxoo on

All the links in this example, including the absence
of a link from box to on, depend on adjacency points
of the form Ax

(−1)
and Ax1 which are updated inde-

pendently of any links. Based on this alone and re-
gardless of whether a link is created from put to on,
A

put
2 will be updated by the word on, which is in-

deed the second argument of the verb put.

4.4 Adjacency Point Update

The update of Axi by α is given by operations
Axi (p) += f(A

α
(−1)

, Aα1 ) which make the value of
Axi (p) in the new lexicon Ls+1 equal to the sum
Axi (p) + f(A

α
(−1)

, Aα1 ) in the old lexicon Ls.

Let Sign(i) be 1 if 0 < i and −1 otherwise. Let

•A
α
i =















true if @l ∈ L(W ) :
Aαi (l) > A

α
i (Stop)

false otherwise

The update of Axi by α begins by incrementing
the count:

#(Axi ) += 1

If α is a boundary symbol (∅l or ∅r) or if x and α
are words separated by stopping punctuation (full
stop, question mark, exclamation mark, semicolon,
comma or dash):

Axi (Stop) += 1

Otherwise, for every l ∈ L(W ):

Axi (l
−1) +=

{

1 if l = [α]
Āα

Sign(−i)
(l) otherwise

(In practice, only l = [α] and the 10 strongest labels
in Aα

Sign(−i)
are updated. Because of the exponen-

tial decay in the strength of labels in Aα
Sign(−i)

, this
is a good approximation.)

If i = −1, 1 and α is not a boundary or blocked
by punctuation, simple bootstrapping takes place by
updating the following properties:

Axi (In
∗) +=











−1 if •A
α
Sign(−i)

+1 if ¬•A
α
Sign(−i)

∧ •A
α
Sign(i)

0 otherwise

Axi (Out) += Ā
α
Sign(−i)

(In∗)

Axi (In) += Ā
α
Sign(−i)

(Out)

4.5 Discussion

To understand the way the labels and properties
are calculated, it is best to look at an example.
The following table gives the linking properties and
strongest labels for the determiner the as learned
from the complete Wall Street Journal corpus (only
Athe

(−1)
and Athe1 are shown):

the
A−1 A1

Stop 12897 Stop 8
In

∗ 14898 In∗ 18914
In 8625 In 4764
Out -13184 Out 21922
[the] 10673 [the] 16461
[of ] 6871 [a] 3107
[in ] 5520 [ the] 2787
[a] 3407 [of] 2347
[for ] 2572 [ company] 2094
[to ] 2094 [’s] 1686

A strong class label [w] indicates that the word w
frequently appears in contexts which are similar to
the. A strong adjacency label [w ] (or [ w]) indicates

388



that w either frequently appears next to the or that
w frequently appears in the same contexts as words
which appear next to the.

The property Stop counts the number of times a
boundary appeared next to the. Because the can of-
ten appear at the beginning of an utterance but must
be followed by a noun or an adjective, it is not sur-
prising that Stop is stronger than any label on the
left but weaker than all labels on the right. In gen-
eral, it is unlikely that a word has an outbound link
on the side on which its Stop strength is stronger
than that of any label. The opposite is not true: a
label stronger than Stop indicates an attachment but
this may also be the result of an inbound link, as in
the following entry for to, where the strong labels on
the left are a result of an inbound link:

to
A−1 A1

Stop 822 Stop 48
In

∗ -4250 In∗ -981
In -57 In -1791
Out -3053 Out 4010
[to] 5912 [to] 7009
[% ] 848 [ the] 3851
[in] 844 [ be] 2208
[the] 813 [will] 1414
[of] 624 [ a] 1158
[a] 599 [the] 954

For this reason, the learning process is based on
the property •A

x
i which indicates where a link is not

possible. Since an outbound link on one word is in-
bound on the other, the inbound/outbound properties
of each word are then calculated by a simple boot-
strapping process as an average of the opposite prop-
erties of the neighboring words.

5 The Weight Function

At each step, the parser must assign a non-negative

weight to every candidate link x
d
→ y which may

be added to an utterance prefix 〈x1, . . . , xk〉, and the
link with the largest (non-zero) weight (with a pref-
erence for links between xk−1 and xk) is added to
the parse. The weight could be assigned directly
based on the In and Out properties of either x or
y but this method is not satisfactory for three rea-
sons: first, the values of these properties on low fre-
quency words are not reliable; second, the values of
the properties on x and y may conflict; third, some
words are ambiguous and require different linking
in different contexts. To solve these problems, the
weight of the link is taken from the values of In and
Out on the best matching label between x and y.

This label depends on both words and is usually a
frequent word with reliable statistics. It serves as a
prototype for the relation between x and y.

5.1 Best Matching Label

A label l is a matching label between Axi and
A

y

Sign(−i)
if Axi (l) > A

x
i (Stop) and either l = (y, 1)

or Ay
Sign(−i)

(l−1) > 0. The best matching label
at Axi is the matching label l such that the match
strength min(Āxi (l), Ā

y

Sign(−i)
(l−1)) is maximal (if

l = (y, 1) then Āy
Sign(−i)

(l−1) is defined to be 1). In
practice, as before, only the top 10 labels in Axi and
A

y

Sign(−i)
are considered.

The best matching label from x to y is calculated
between Axi and A

y

Sign(−i)
such that Axi is on the

same side of x as y and was either already used to
create a link or is the first adjacency point on that
side of x which was not yet used. This means that
the adjacency points on each side have to be used
one by one, but may be used more than once. The
reason is that optional arguments of x usually do
not have an adjacency point of their own but have
the same labels as obligatory arguments of x and
can share their adjacency point. The Axi with the
strongest matching label is selected, with a prefer-
ence for the unused adjacency point.

As in the learning process, label matching is
blocked between words which are separated by stop-
ping punctuation.

5.2 Calculating the Link Weight

The best matching label l = (w, δ) from x to y can
be either a class (δ = 0) or an adjacency (δ = 1) la-
bel at Axi . If it is a class label, w can be seen as tak-
ing the place of x and all words separating it from y
(which are already linked to x). If l is an adjacency
label, w can be seen to take the place of y. The cal-

culation of the weight Wt(x
d
→ y) of the link from

x to y is therefore based on the strengths of the In
and Out properties of Awσ where σ = Sign(i) if
l = (w, 0) and σ = Sign(−i) if l = (w, 1). In ad-
dition, the weight is bounded from above by the best
label match strength, s(l):

• If l = (w, 0) and Awσ (Out) > 0:

Wt(x
0
→ y) = min(s(l), Āwσ (Out))

389



WSJ10 WSJ40 Negra10 Negra40
Model UP UR UF1 UP UR UF1 UP UR UF1 UP UR UF1
Right-branching 55.1 70.0 61.7 35.4 47.4 40.5 33.9 60.1 43.3 17.6 35.0 23.4
Right-branching+punct. 59.1 74.4 65.8 44.5 57.7 50.2 35.4 62.5 45.2 20.9 40.4 27.6

Parsing from POS
CCM 64.2 81.6 71.9 48.1 85.5 61.6
DMV+CCM(POS) 69.3 88.0 77.6 49.6 89.7 63.9
U-DOP 70.8 88.2 78.5 63.9 51.2 90.5 65.4
UML-DOP 82.9 66.4 67.0

Parsing from plain text
DMV+CCM(DISTR.) 65.2 82.8 72.9
Incremental 75.6 76.2 75.9 58.9 55.9 57.4 51.0 69.8 59.0 34.8 48.9 40.6
Incremental (right to left) 75.9 72.5 74.2 59.3 52.2 55.6 50.4 68.3 58.0 32.9 45.5 38.2

Table 1: Parsing results on WSJ10, WSJ40, Negra10 and Negra40.

• If l = (w, 1):

◦ If Awσ (In) > 0:

Wt(x
d
→ y) = min(s(l), Āwσ (In))

◦ Otherwise, if Awσ (In
∗) ≥ |Awσ (In)|:

Wt(x
d
→ y) = min(s(l), Āwσ (In

∗))

where if Awσ (In
∗) < 0 and Awσ (Out) ≤ 0 then

d = 1 and otherwise d = 0.

• If Awσ (Out) ≤ 0 and A
w
σ (In) ≤ 0 and either

l = (w, 1) or Awσ (Out) = 0:

Wt(x
0
→ y) = s(l)

• In all other cases, Wt(x
d
→ y) = 0.

A link x
1
→ y attaches x to y but does not place

y inside the smallest bracket covering x. Such links
are therefore created in the second case above, when
the attachment indication is mixed.

To explain the third case, recall that s(l) > 0
means that the label l is stronger than Stop on Axi .
This implies a link unless the properties of w block
it. One way in which w can block the link is to have
a positive strength for the link in the opposite direc-
tion. Another way in which the properties of w can
block the link is if l = (w, 0) and Awσ (Out) < 0,
that is, if the learning process has explicitly deter-
mined that no outbound link from w (which repre-
sents x in this case) is possible. The same conclu-
sion cannot be drawn from a negative value for the
In property when l = (w, 1) because, as with stan-
dard dependencies, a word determines its outbound
links much more strongly than its inbound links.

6 Experiments

The incremental parser was tested on the Wall Street
Journal and Negra Corpora.2 Parsing accuracy was
evaluated on the subsets WSJX and NegraX of
these corpora containing sentences of length at most
X (excluding punctuation). Some of these subsets
were used for scoring in (Klein and Manning, 2004;
Bod, 2006a; Bod, 2006b). I also use the same preci-
sion and recall measures used in those papers: mul-
tiple brackets and brackets covering a single word
were not counted, but the top bracket was.

The incremental parser learns while parsing, and
it could, in principle, simply be evaluated for a sin-
gle pass of the data. But, because the quality of the
parses of the first sentences would be low, I first
trained on the full corpus and then measured pars-
ing accuracy on the corpus subset. By training on
the full corpus, the procedure differs from that of
Klein, Manning and Bod who only train on the sub-
set of bounded length sentences. However, this ex-
cludes the induction of parts-of-speech for parsing
from plain text. When Klein and Manning induce
the parts-of-speech, they do so from a much larger
corpus containing the full WSJ treebank together
with additional WSJ newswire (Klein and Manning,
2002). The comparison between the algorithms re-
mains, therefore, valid.

Table 1 gives two baselines and the parsing re-
sults for WSJ10, WSJ40, Negra10 and Negra40
for recent unsupervised parsing algorithms: CCM

2I also tested the incremental parser on the Chinese Tree-
bank version 5.0, achieving an F1 score of 54.6 on CTB10 and
38.0 on CTB40. Because this version of the treebank is newer
and clearly different from that used by previous papers, the re-
sults are not comparable and only given here for completeness.

390



and DMV+CCM (Klein and Manning, 2004), U-
DOP (Bod, 2006b) and UML-DOP (Bod, 2006a).
The middle part of the table gives results for pars-
ing from part-of-speech sequences extracted from
the treebank while the bottom part of the table given
results for parsing from plain text. Results for the in-
cremental parser are given for learning and parsing
from left to right and from right to left.

The first baseline is the standard right-branching
baseline. The second baseline modifies right-
branching by using punctuation in the same way as
the incremental parser: brackets (except the top one)
are not allowed to contain stopping punctuation. It
can be seen that punctuation accounts for merely a
small part of the incremental parser’s improvement
over the right-branching heuristic.

Comparing the two algorithms parsing from plain
text (of WSJ10), it can be seen that the incremental
parser has a somewhat higher combined F1 score,
with better precision but worse recall. This is be-
cause Klein and Manning’s algorithms (as well as
Bod’s) always generate binary parse trees, while
here no such condition is imposed. The small differ-
ence between the recall (76.2) and precision (75.6)
of the incremental parser shows that the number of
brackets induced by the parser is very close to that
of the corpus3 and that the parser captures the same
depth of syntactic structure as that which was used
by the corpus annotators.

Incremental parsing from right to left achieves re-
sults close to those of parsing from left to right. This
shows that the incremental parser has no built-in bias
for right branching structures.4 The slight degra-
dation in performance may suggest that language
should not, after all, be processed backwards.

While achieving state of the art accuracy, the algo-
rithm also proved to be fast, parsing (on a 1.86GHz
Centrino laptop) at a rate of around 4000 words/sec.
and learning (including parsing) at a rate of 3200 –
3600 words/sec. The effect of sentence length on
parsing speed is small: the full WSJ corpus was
parsed at 3900 words/sec. while WSJ10 was parsed
at 4300 words/sec.

3The algorithm produced 35588 brackets compared with
35302 brackets in the corpus.

4I would like to thank Alexander Clark for suggesting this
test.

7 Conclusions

The unsupervised parser I presented here attempts
to make use of several universal properties of nat-
ural languages: it captures the skewness of syntac-
tic trees in its syntactic representation, restricts the
search space by processing utterances incrementally
(as humans do) and relies on the Zipfian distribution
of words to guide its parsing decisions. It uses an
elementary bootstrapping process to deduce the ba-
sic properties of the language being parsed. The al-
gorithm seems to successfully capture some of these
basic properties, but can be further refined to achieve
high quality parsing. The current algorithm is a good
starting point for such refinement because it is so
very simple.

Acknowledgments I would like to thank Dick de
Jongh for many hours of discussion, and Remko
Scha, Reut Tsarfaty and Jelle Zuidema for reading
and commenting on various versions of this paper.

References
Rens Bod. 2006a. An all-subtrees approach to unsuper-

vised parsing. In Proceedings of COLING-ACL 2006.

Rens Bod. 2006b. Unsupervised parsing with U-DOP.
In Proceedings of CoNLL 10.

Alexander Clark. 2000. Inducing syntactic categories
by context distribution clustering. In Proceedings of
CoNLL 4.

Matthew W. Crocker, Martin Pickering, and Charles
Clifton. 2000. Architectures and Mechanisms for
Language Processing. Cambridge University Press.

Dan Klein and Christopher D. Manning. 2002. A gener-
ative constituent-context model for improved grammar
induction. In Proceedings of ACL 40, pages 128–135.

Dan Klein and Christopher D. Manning. 2004. Corpus-
based induction of syntactic structure: Models of de-
pendency and constituency. In Proceedings of ACL 42.

David McClosky, Eugene Charniak, and Mark Johnson.
2006. Effective self-training for parsing. In Proceed-
ings of HLT-NAACL 2006.

Hinrich Schütze. 1995. Distributional part-of-speech
tagging. In Proceedings of EACL 7.

Patrick Sturt and Matthew W. Crocker. 1996. Mono-
tonic syntactic processing: A cross-linguistic study of
attachment and reanalysis. Language and Cognitive
Processes, 11(5):449–492.

391


