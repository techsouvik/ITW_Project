













































A Deductive Approach to Dependency Parsing


Proceedings of ACL-08: HLT, pages 968–976,
Columbus, Ohio, USA, June 2008. c©2008 Association for Computational Linguistics

A Deductive Approach to Dependency Parsing∗

Carlos Gómez-Rodrı́guez
Departamento de Computación
Universidade da Coruña, Spain

cgomezr@udc.es

John Carroll and David Weir
Department of Informatics

University of Sussex, United Kingdom
{johnca,davidw}@sussex.ac.uk

Abstract

We define a new formalism, based on Sikkel’s
parsing schemata for constituency parsers,
that can be used to describe, analyze and com-
pare dependency parsing algorithms. This
abstraction allows us to establish clear rela-
tions between several existing projective de-
pendency parsers and prove their correctness.

1 Introduction
Dependency parsing consists of finding the structure
of a sentence as expressed by a set of directed links
(dependencies) between words. This is an alterna-
tive to constituency parsing, which tries to find a di-
vision of the sentence into segments (constituents)
which are then broken up into smaller constituents.
Dependency structures directly show head-modifier
and head-complement relationships which form the
basis of predicate argument structure, but are not
represented explicitly in constituency trees, while
providing a representation in which no non-lexical
nodes have to be postulated by the parser. In addi-
tion to this, some dependency parsers are able to rep-
resent non-projective structures, which is an impor-
tant feature when parsing free word order languages
in which discontinuous constituents are common.

The formalism of parsing schemata (Sikkel, 1997)
is a useful tool for the study of constituency parsers
since it provides formal, high-level descriptions
of parsing algorithms that can be used to prove
their formal properties (such as correctness), es-
tablish relations between them, derive new parsers
from existing ones and obtain efficient implementa-
tions automatically (Gómez-Rodrı́guez et al., 2007).
The formalism was initially defined for context-free
grammars and later applied to other constituency-
based formalisms, such as tree-adjoining grammars

∗Partially supported by Ministerio de Educación y Ciencia
and FEDER (TIN2004-07246-C03, HUM2007-66607-C04),
Xunta de Galicia (PGIDIT07SIN005206PR, PGIDIT05PXIC-
10501PN, PGIDIT05PXIC30501PN, Rede Galega de Proc. da
Linguaxe e RI) and Programa de Becas FPU.

(Alonso et al., 1999). However, since parsing
schemata are defined as deduction systems over sets
of constituency trees, they cannot be used to de-
scribe dependency parsers.

In this paper, we define an analogous formalism
that can be used to define, analyze and compare de-
pendency parsers. We use this framework to provide
uniform, high-level descriptions for a wide range of
well-known algorithms described in the literature,
and we show how they formally relate to each other
and how we can use these relations and the formal-
ism itself to prove their correctness.

1.1 Parsing schemata
Parsing schemata (Sikkel, 1997) provide a formal,
simple and uniform way to describe, analyze and
compare different constituency-based parsers.

The notion of a parsing schema comes from con-
sidering parsing as a deduction process which gener-
ates intermediate results called items. An initial set
of items is directly obtained from the input sentence,
and the parsing process consists of the application of
inference rules (deduction steps) which produce new
items from existing ones. Each item contains a piece
of information about the sentence’s structure, and a
successful parsing process will produce at least one
final item containing a full parse tree for the sentence
or guaranteeing its existence.

Items in parsing schemata are formally defined
as sets of partial parse trees from a set denoted
Trees(G), which is the set of all the possible par-
tial parse trees that do not violate the constraints im-
posed by a grammar G. More formally, an item set
I is defined by Sikkel as a quotient set associated
with an equivalence relation on Trees(G).1

Valid parses for a string are represented by
items containing complete marked parse trees for
that string. Given a context-free grammar G =

1While Shieber et al. (1995) also view parsers as deduction
systems, Sikkel formally defines items and related concepts,
providing the mathematical tools to reason about formal prop-
erties of parsers.

968



(N, Σ, P, S), a marked parse tree for a string
w1 . . . wn is any tree τ ∈ Trees(G)/root(τ) =
S∧yield(τ) = w1 . . . wn

2. An item containing such
a tree for some arbitrary string is called a final item.
An item containing such a tree for a particular string
w1 . . . wn is called a correct final item for that string.

For each input string, a parsing schema’s deduc-
tion steps allow us to infer a set of items, called valid
items for that string. A parsing schema is said to
be sound if all valid final items it produces for any
arbitrary string are correct for that string. A pars-
ing schema is said to be complete if all correct fi-
nal items are valid. A correct parsing schema is one
which is both sound and complete. A correct parsing
schema can be used to obtain a working implemen-
tation of a parser by using deductive engines such
as the ones described by Shieber et al. (1995) and
Gómez-Rodrı́guez et al. (2007) to obtain all valid fi-
nal items.

2 Dependency parsing schemata
Although parsing schemata were initially defined for
context-free parsers, they can be adapted to different
constituency-based grammar formalisms, by finding
a suitable definition of Trees(G) for each particular
formalism and a way to define deduction steps from
its rules. However, parsing schemata are not directly
applicable to dependency parsing, since their formal
framework is based on constituency trees.

In spite of this problem, many of the dependency
parsers described in the literature are constructive,
in the sense that they proceed by combining smaller
structures to form larger ones until they find a com-
plete parse for the input sentence. Therefore, it
is possible to define a variant of parsing schemata,
where these structures can be defined as items and
the strategies used for combining them can be ex-
pressed as inference rules. However, in order to de-
fine such a formalism we have to tackle some issues
specific to dependency parsers:
• Traditional parsing schemata are used to de-

fine grammar-based parsers, in which the parsing
process is guided by some set of rules which are
used to license deduction steps: for example, an
Earley Predictor step is tied to a particular gram-
mar rule, and can only be executed if such a rule
exists. Some dependency parsers are also grammar-

2
w

i
is shorthand for the marked terminal (wi, i). These are

used by Sikkel (1997) to link terminal symbols to string posi-
tions so that an input sentence can be represented as a set of
trees which are used as initial items (hypotheses) for the de-
duction system. Thus, a sentence w1 . . . wn produces a set of
hypotheses {{w1(w1)}, . . . , {wn(wn)}}.

Figure 1: Representation of a dependency structure with
a tree. The arrows below the words correspond to its as-
sociated dependency graph.

based: for example, those described by Lombardo
and Lesmo (1996), Barbero et al. (1998) and Ka-
hane et al. (1998) are tied to the formalizations of de-
pendency grammar using context-free like rules de-
scribed by Hays (1964) and Gaifman (1965). How-
ever, many of the most widely used algorithms (Eis-
ner, 1996; Yamada and Matsumoto, 2003) do not use
a formal grammar at all. In these, decisions about
which dependencies to create are taken individually,
using probabilistic models (Eisner, 1996) or classi-
fiers (Yamada and Matsumoto, 2003). To represent
these algorithms as deduction systems, we use the
notion of D-rules (Covington, 1990). D-rules take
the form a → b, which says that word b can have a
as a dependent. Deduction steps in non-grammar-
based parsers can be tied to the D-rules associated
with the links they create. In this way, we obtain
a representation of the semantics of these parsing
strategies that is independent of the particular model
used to take the decisions associated with each D-
rule.

• The fundamental structures in dependency pars-
ing are dependency graphs. Therefore, as items
for constituency parsers are defined as sets of par-
tial constituency trees, it is tempting to define items
for dependency parsers as sets of partial dependency
graphs. However, predictive grammar-based algo-
rithms such as those of Lombardo and Lesmo (1996)
and Kahane et al. (1998) have operations which pos-
tulate rules and cannot be defined in terms of depen-
dency graphs, since they do not do any modifications
to the graph. In order to make the formalism general
enough to include these parsers, we define items in
terms of sets of partial dependency trees as shown in
Figure 1. Note that a dependency graph can always
be extracted from such a tree.

• Some of the most popular dependency parsing
algorithms, like that of Eisner (1996), work by con-
necting spans which can represent disconnected de-
pendency graphs. Such spans cannot be represented
by a single dependency tree. Therefore, our formal-
ism allows items to be sets of forests of partial de-
pendency trees, instead of sets of trees.

969



Taking these considerations into account, we de-
fine the concepts that we need to describe item sets
for dependency parsers:

Let Σ be an alphabet of terminal symbols.
Partial dependency trees: We define the set of

partial dependency trees (D-trees) as the set of finite
trees where children of each node have a left-to-right
ordering, each node is labelled with an element of
Σ∪(Σ×N), and the following conditions hold:
• All nodes labelled with marked terminals wi ∈

(Σ×N) are leaves,
• Nodes labelled with terminals w ∈ Σ do not have

more than one daughter labelled with a marked
terminal, and if they have such a daughter node, it
is labelled wi for some i ∈ N,

• Left siblings of nodes labelled with a marked ter-
minal wk do not have any daughter labelled wj
with j ≥ k. Right siblings of nodes labelled with
a marked terminal wk do not have any daughter
labelled wj with j ≤ k.
We denote the root node of a partial dependency

tree t as root(t). If root(t) has a daughter node la-
belled with a marked terminal wh, we will say that
wh is the head of the tree t, denoted by head(t). If
all nodes labelled with terminals in t have a daughter
labelled with a marked terminal, t is grounded.

Relationship between trees and graphs: Let
t ∈ D-trees be a partial dependency tree; g(t), its
associated dependency graph, is a graph (V, E)
• V ={wi ∈ (Σ×N) | wi is the label of a node in

t},
• E ={(wi, wj) ∈ (Σ×N)

2 | C, D are nodes in t
such that D is a daughter of C, wj the label of a
daughter of C, wi the label of a daughter of D}.
Projectivity: A partial dependency tree t ∈

D-trees is projective iff yield(t) cannot be written
as . . . wi . . . wj . . . where i ≥ j.

It is easy to verify that the dependency graph
g(t) is projective with respect to the linear order of
marked terminals wi, according to the usual defi-
nition of projectivity found in the literature (Nivre,
2006), if and only if the tree t is projective.

Parse tree: A partial dependency tree t ∈
D-trees is a parse tree for a given string w1 . . . wn
if its yield is a permutation of w1 . . . wn. If its yield
is exactly w1 . . . wn, we will say it is a projective
parse tree for the string.

Item set: Let δ ⊆ D-trees be the set of de-
pendency trees which are acceptable according to a
given grammar G (which may be a grammar of D-
rules or of CFG-like rules, as explained above). We

define an item set for dependency parsing as a set
I ⊆ Π, where Π is a partition of 2δ.

Once we have this definition of an item set for
dependency parsing, the remaining definitions are
analogous to those in Sikkel’s theory of constituency
parsing (Sikkel, 1997), so we will not include them
here in full detail. A dependency parsing system is
a deduction system (I, H, D) where I is a depen-
dency item set as defined above, H is a set contain-
ing initial items or hypotheses, and D ⊆ (2(H∪I) ×
I) is a set of deduction steps defining an inference
relation `.

Final items in this formalism will be those con-
taining some forest F containing a parse tree for
some arbitrary string. An item containing such a tree
for a particular string w1 . . . wn will be called a cor-
rect final item for that string in the case of nonprojec-
tive parsers. When defining projective parsers, cor-
rect final items will be those containing projective
parse trees for w1 . . . wn. This distinction is relevant
because the concepts of soundness and correctness
of parsing schemata are based on correct final items
(cf. section 1.1), and we expect correct projective
parsers to produce only projective structures, while
nonprojective parsers should find all possible struc-
tures including nonprojective ones.

3 Some practical examples
3.1 Col96 (Collins, 96)
One of the most straightforward projective depen-
dency parsing strategies is the one described by
Collins (1996), directly based on the CYK pars-
ing algorithm. This parser works with dependency
trees which are linked to each other by creating
links between their heads. Its item set is defined as
ICol96 = {[i, j, h] | 1 ≤ i ≤ h ≤ j ≤ n}, where an
item [i, j, h] is defined as the set of forests containing
a single projective dependency tree t such that t is
grounded, yield(t) = wi . . . wj and head(t) = wh.

For an input string w1 . . . wn, the set of hypothe-
ses is H = {[i, i, i] | 0 ≤ i ≤ n + 1}, i.e., the set
of forests containing a single dependency tree of the
form wi(wi). This same set of hypotheses can be
used for all the parsers, so we will not make it ex-
plicit for subsequent schemata.3

The set of final items is {[1, n, h] | 1 ≤ h ≤ n}:
these items trivially represent parse trees for the in-
put sentence, where wh is the sentence’s head. The
deduction steps are shown in Figure 2.

3Note that the words w0 and wn+1 used in the definition do
not appear in the input: these are dummy terminals that we will
call beginning of sentence (BOS) and end of sentence (EOS)
marker, respectively; and will be needed by some parsers.

970



Col96 (Collins,96):

R-Link

[i, j, h1]
[j + 1, k, h2]

[i, k, h2]
wh1 → wh2

L-Link

[i, j, h1]
[j + 1, k, h2]

[i, k, h1]
wh2 → wh1

Eis96 (Eisner, 96):

Initter
[i, i, i] [i + 1, i + 1, i + 1]

[i, i + 1, F, F ]

R-Link
[i, j, F, F ]

[i, j, T, F ]
wi → wj

L-Link
[i, j, F, F ]

[i, j, F, T ]
wj → wi

CombineSpans

[i, j, b, c]
[j, k, not(c), d]

[i, k, b, d]

ES99 (Eisner and Satta, 99):

R-Link
[i, j, i] [j + 1, k, k]

[i, k, k]
wi → wk

L-Link
[i, j, i] [j + 1, k, k]

[i, k, i]
wk → wi

R-Combiner
[i, j, i] [j, k, j]

[i, k, i]

L-Combiner
[i, j, j] [j, k, k]

[i, k, k]

YM03 (Yamada and Matsumoto, 2003):

Initter
[i, i, i] [i + 1, i + 1, i + 1]

[i, i + 1]

R-Link

[i, j]
[j, k]

[i, k]
wj → wk L-Link

[i, j]
[j, k]

[i, k]
wj → wi

LL96 (Lombardo and Lesmo, 96):

Initter
[(.S), 1, 0]

∗(S)∈P Predictor
[A(α.Bβ), i, j]

[B(.γ), j + 1, j]
B(γ)∈P

Scanner
[A(α. ? β), i, h− 1] [h, h, h]

[A(α ? .β), i, h]
wh IS A

Completer
[A(α.Bβ), i, j] [B(γ.), j + 1, k]

[A(αB.β), i, k]

Figure 2: Deduction steps of the parsing schemata for some well-known dependency parsers.

As we can see, we use D-rules as side conditions
for deduction steps, since this parsing strategy is not
grammar-based. Conceptually, the schema we have
just defined describes a recogniser: given a set of D-
rules and an input string wi . . . wn, the sentence can
be parsed (projectively) under those D-rules if and
only if this deduction system can infer a correct final
item. However, when executing this schema with a
deductive engine, we can recover the parse forest by
following back pointers in the same way as is done
with constituency parsers (Billot and Lang, 1989).

Of course, boolean D-rules are of limited interest
in practice. However, this schema provides a formal-
ization of a parsing strategy which is independent
of the way linking decisions are taken in a partic-
ular implementation. In practice, statistical models
can be used to decide whether a step linking words
a and b (i.e., having a → b as a side condition) is
executed or not, and probabilities can be attached to
items in order to assign different weights to different
analyses of the sentence. The same principle applies
to the rest of D-rule-based parsers described in this
paper.

3.2 Eis96 (Eisner, 96)
By counting the number of free variables used in
each deduction step of Collins’ parser, we can con-
clude that it has a time complexity of O(n5). This
complexity arises from the fact that a parentless
word (head) may appear in any position in the par-
tial results generated by the parser; the complexity
can be reduced to O(n3) by ensuring that parentless
words can only appear at the first or last position
of an item. This is the principle behind the parser
defined by Eisner (1996), which is still in wide use
today (Corston-Oliver et al., 2006; McDonald et al.,

2005a).
The item set for Eisner’s parsing schema is

IEis96 = {[i, j, T, F ] | 0 ≤ i ≤ j ≤ n} ∪
{[i, j, F, T ] | 0 ≤ i ≤ j ≤ n} ∪ {[i, j, F, F ] |
0 ≤ i ≤ j ≤ n}, where each item [i, j, T, F ] is de-
fined as the item [i, j, j] ∈ ICol96, each item
[i, j, F, T ] is defined as the item [i, j, i] ∈ ICol96,
and each item [i, j, F, F ] is defined as the set
of forests of the form {t1, t2} such that t1 and
t2 are grounded, head(t1) = wi, head(t2) = wj ,
and ∃k ∈ N(i ≤ k < j)/yield(t1) = wi . . . wk ∧
yield(t2) = wk+1 . . . wj .

Note that the flags b, c in an item [i, j, b, c] indi-
cate whether the words in positions i and j, respec-
tively, have a parent in the item or not. Items with
one of the flags set to T represent dependency trees
where the word in position i or j is the head, while
items with both flags set to F represent pairs of trees
headed at positions i and j, and therefore correspond
to disconnected dependency graphs.

Deduction steps4 are shown in Figure 2. The
set of final items is {[0, n, F, T ]}. Note that these
items represent dependency trees rooted at the BOS
marker w0, which acts as a “dummy head” for the
sentence. In order for the algorithm to parse sen-
tences correctly, we will need to define D-rules to
allow w0 to be linked to the real sentence head.

3.3 ES99 (Eisner and Satta, 99)
Eisner and Satta (1999) define an O(n3) parser for
split head automaton grammars that can be used

4Alternatively, we could consider items of the form [i, i +
1, F, F ] to be hypotheses for this parsing schema, so we would
not need an Initter step. However, we have chosen to use a stan-
dard set of hypotheses valid for all parsers because this allows
for more straightforward proofs of relations between schemata.

971



for dependency parsing. This algorithm is con-
ceptually simpler than Eis96, since it only uses
items representing single dependency trees, avoid-
ing items of the form [i, j, F, F ]. Its item set is
IES99 = {[i, j, i] | 0 ≤ i ≤ j ≤ n} ∪ {[i, j, j] |
0 ≤ i ≤ j ≤ n}, where items are defined as in
Collins’ parsing schema.

Deduction steps are shown in Figure 2, and the set
of final items is {[0, n, 0]}. (Parse trees have w0 as
their head, as in the previous algorithm).

Note that, when described for head automaton
grammars as in Eisner and Satta (1999), this algo-
rithm seems more complex to understand and imple-
ment than the previous one, as it requires four differ-
ent kinds of items in order to keep track of the state
of the automata used by the grammars. However,
this abstract representation of its underlying seman-
tics as a dependency parsing schema shows that this
parsing strategy is in fact conceptually simpler for
dependency parsing.

3.4 YM03 (Yamada and Matsumoto, 2003)
Yamada and Matsumoto (2003) define a determinis-
tic, shift-reduce dependency parser guided by sup-
port vector machines, which achieves over 90% de-
pendency accuracy on section 23 of the Penn tree-
bank. Parsing schemata are not suitable for directly
describing deterministic parsers, since they work at
a high abstraction level where a set of operations
are defined without imposing order constraints on
them. However, many deterministic parsers can be
viewed as particular optimisations of more general,
nondeterministic algorithms. In this case, if we rep-
resent the actions of the parser as deduction steps
while abstracting from the deterministic implemen-
tation details, we obtain an interesting nondetermin-
istic parser.

Actions in Yamada and Matsumoto’s parser create
links between two target nodes, which act as heads
of neighbouring dependency trees. One of the ac-
tions creates a link where the left target node be-
comes a child of the right one, and the head of a
tree located directly to the left of the target nodes
becomes the new left target node. The other ac-
tion is symmetric, performing the same operation
with a right-to-left link. An O(n3) nondetermin-
istic parser generalising this behaviour can be de-
fined by using an item set IY M03 = {[i, j] |
0 ≤ i ≤ j ≤ n + 1}, where each item [i, j] is de-
fined as the item [i, j, F, F ] in IEis96; and the de-
duction steps are shown in Figure 2.

The set of final items is {[0, n + 1]}. In order for
this set to be well-defined, the grammar must have

no D-rules of the form wi → wn+1, i.e., it must not
allow the EOS marker to govern any words. If this
is the case, it is trivial to see that every forest in an
item of the form [0, n + 1] must contain a parse tree
rooted at the BOS marker and with yield w0 . . . wn.

As can be seen from the schema, this algorithm
requires less bookkeeping than any other of the
parsers described here.

3.5 LL96 (Lombardo and Lesmo, 96) and
other Earley-based parsers

The algorithms in the above examples are based on
taking individual decisions about dependency links,
represented by D-rules. Other parsers, such as that
of Lombardo and Lesmo (1996), use grammars with
context-free like rules which encode the preferred
order of dependents for each given governor, as de-
fined by Gaifman (1965). For example, a rule of the
form N(Det ∗ PP ) is used to allow N to have Det
as left dependent and PP as right dependent.

The algorithm by Lombardo and Lesmo (1996)
is a version of Earley’s context-free grammar parser
(Earley, 1970) using Gaifman’s dependency gram-
mar, and can be written by using an item set
ILomLes = {[A(α.β), i, j] | A(αβ) ∈ P ∧
1 ≤ i ≤ j ≤ n}, where each item [A(α.β), i, j] rep-
resents the set of partial dependency trees rooted at
A, where the direct children of A are αβ, and the
subtrees rooted at α have yield wi . . . wj . The de-
duction steps for the schema are shown in Figure 2,
and the final item set is {[(S.), 1, n]}.

As we can see, the schema for Lombardo and
Lesmo’s parser resembles the Earley-style parser in
Sikkel (1997), with some changes to adapt it to de-
pendency grammar (for example, the Scanner al-
ways moves the dot over the head symbol ∗).

Analogously, other dependency parsing schemata
based on CFG-like rules can be obtained by mod-
ifying context-free grammar parsing schemata of
Sikkel (1997) in a similar way. The algorithm by
Barbero et al. (1998) can be obtained from the left-
corner parser, and the one by Courtin and Genthial
(1998) is a variant of the head-corner parser.

3.6 Pseudo-projectivity

Pseudo-projective parsers can generate non-
projective analyses in polynomial time by using
a projective parsing strategy and postprocessing
the results to establish nonprojective links. For
example, the algorithm by Kahane et al. (1998) uses
a projective parsing strategy like that of LL96, but
using the following initializer step instead of the

972



Initter and Predictor:5
Initter

[A(α), i, i− 1]
A(α) ∈ P ∧ 1 ≤ i ≤ n

4 Relations between dependency parsers
The framework of parsing schemata can be used to
establish relationships between different parsing al-
gorithms and to obtain new algorithms from existing
ones, or derive formal properties of a parser (such as
soundness or correctness) from the properties of re-
lated algorithms.

Sikkel (1994) defines several kinds of relations
between schemata, which fall into two categories:
generalisation relations, which are used to obtain
more fine-grained versions of parsers, and filtering
relations, which can be seen as the reverse of gener-
alisation and are used to reduce the number of items
and/or steps needed for parsing. He gives a formal
definition of each kind of relation. Informally, a
parsing schema can be generalised from another via
the following transformations:

• Item refinement: We say that P1
ir
−→ P2 (P2 is an

item refinement of P1) if there is a mapping be-
tween items in both parsers such that single items
in P1 are broken into multiple items in P2 and in-
dividual deductions are preserved.

• Step refinement: We say that P1
sr
−→ P2 if the

item set of P1 is a subset of that of P2 and every
single deduction step in P1 can be emulated by a
sequence of inferences in P2.
On the other hand, a schema can be obtained from

another by filtering in the following ways:

• Static/dynamic filtering: P1
sf/df
−−−→ P2 if the item

set of P2 is a subset of that of P1 and P2 allows a
subset of the direct inferences in P1

6.
• Item contraction: The inverse of item refinement.

P1
ic
−→ P2 if P2

ir
−→ P1.

• Step contraction: The inverse of step refinement.
P1

sc
−→ P2 if P2

sr
−→ P1.

All the parsers described in section 3 can be re-
lated via generalisation and filtering, as shown in
Figure 3. For space reasons we cannot show formal
proofs of all the relations, but we sketch the proofs
for some of the more interesting cases:

5The initialization step as reported in Kahane’s paper is dif-
ferent from this one, as it directly consumes a nonterminal from
the input. However, using this step results in an incomplete
algorithm. The problem can be fixed either by using the step
shown here instead (bottom-up Earley strategy) or by adding an
additional step turning it into a bottom-up Left-Corner parser.

6Refer to Sikkel (1994) for the distinction between static and
dynamic filtering, which we will not use here.

4.1 YM03
sr
−→ Eis96

It is easy to see from the schema definitions that
IY M03 ⊆ IEis96. In order to prove the relation
between these parsers, we need to verify that every
deduction step in YM03 can be emulated by a se-
quence of inferences in Eis96. In the case of the
Initter step this is trivial, since the Initters of both
parsers are equivalent. If we write the R-Link step in
the notation we have used for Eisner items, we have
R-Link

[i, j, F, F ] [j, k, F, F ]

[i, k, F, F ]
wj → wk

This can be emulated in Eisner’s parser by an
R-Link step followed by a CombineSpans step:
[j, k, F, F ] ` [j, k, T, F ] (by R-Link),
[j, k, T, F ], [i, j, F, F ] ` [i, k, F, F ] (by CombineSpans).

Symmetrically, the L-Link step in YM03 can be
emulated by an L-Link followed by a CombineSpans
in Eis96.

4.2 ES99
sr
−→ Eis96

If we write the R-Link step in Eisner and Satta’s
parser in the notation for Eisner items, we have

R-Link
[i, j, F, T ] [j + 1, k, T, F ]

[i, k, T, F ]
wi → wk

This inference can be emulated in Eisner’s parser
as follows:
` [j, j + 1, F, F ] (by Initter),
[i, j, F, T ], [j, j + 1, F, F ] ` [i, j + 1, F, F ] (CombineSpans),
[i, j + 1, F, F ], [j + 1, k, T, F ] ` [i, k, F, F ] (CombineSpans),
[i, k, F, F ] ` [i, k, T, F ] (by R-Link).
The proof corresponding to the L-Link step is sym-
metric. As for the R-Combiner and L-Combiner
steps in ES99, it is easy to see that they are partic-
ular cases of the CombineSpans step in Eis96, and
therefore can be emulated by a single application of
CombineSpans.

Note that, in practice, the relations in sections 4.1
and 4.2 mean that the ES99 and YM03 parsers are
superior to Eis96, since they generate fewer items
and need fewer steps to perform the same deduc-
tions. These two parsers also have the interesting
property that they use disjoint item sets (one uses
items representing trees while the other uses items
representing pairs of trees); and the union of these
disjoint sets is the item set used by Eis96. Also note
that the optimisation in YM03 comes from contract-
ing deductions in Eis96 so that linking operations
are immediately followed by combining operations;
while ES99 does the opposite, forcing combining
operations to be followed by linking operations.

4.3 Other relations
If we generalise the linking steps in ES99 so that the
head of each item can be in any position, we obtain a

973



Figure 3: Formal relations between several well-known dependency parsers. Arrows going upwards correspond to
generalisation relations, while those going downwards correspond to filtering. The specific subtype of relation is
shown in each arrow’s label, following the notation in Section 4.

correct O(n5) parser which can be filtered to Col96
just by eliminating the Combiner steps.

From Col96, we can obtain an O(n5) head-corner
parser based on CFG-like rules by an item refine-
ment in which each Collins item [i, j, h] is split into
a set of items [A(α.β.γ), i, j, h]. Of course, the for-
mal refinement relation between these parsers only
holds if the D-rules used for Collins’ parser corre-
spond to the CFG rules used for the head-corner
parser: for every D-rule B → A there must be a
corresponding CFG-like rule A → . . . B . . . in the
grammar used by the head-corner parser.

Although this parser uses three indices i, j, h, us-
ing CFG-like rules to guide linking decisions makes
the h indices unnecessary, so they can be removed.
This simplification is an item contraction which re-
sults in an O(n3) head-corner parser. From here,
we can follow the procedure in Sikkel (1994) to
relate this head-corner algorithm to parsers analo-
gous to other algorithms for context-free grammars.
In this way, we can refine the head-corner parser
to a variant of de Vreught and Honig’s algorithm
(Sikkel, 1997), and by successive filters we reach a
left-corner parser which is equivalent to the one de-
scribed by Barbero et al. (1998), and a step contrac-
tion of the Earley-based dependency parser LL96.
The proofs for these relations are the same as those
described in Sikkel (1994), except that the depen-
dency variants of each algorithm are simpler (due
to the absence of epsilon rules and the fact that the
rules are lexicalised).

5 Proving correctness
Another useful feature of the parsing schemata
framework is that it provides a formal way to de-
fine the correctness of a parser (see last paragraph
of Section 1.1) which we can use to prove that our
parsers are correct. Furthermore, relations between
schemata can be used to derive the correctness of

a schema from that of related ones. In this sec-
tion, we will show how we can prove that the YM03
and ES99 algorithms are correct, and use that fact to
prove the correctness of Eis96.

5.1 ES99 is correct
In order to prove the correctness of a parser, we must
prove its soundness and completeness (see section
1.1). Soundness is generally trivial to verify, since
we only need to check that every individual deduc-
tion step in the parser infers a correct consequent
item when applied to correct antecedents (i.e., in this
case, that steps always generate non-empty items
that conform to the definition in 3.3). The difficulty
is proving completeness, for which we need to prove
that all correct final items are valid (i.e., can be in-
ferred by the schema). To show this, we will prove
the stronger result that all correct items are valid.

We will show this by strong induction on the
length of items, where the length of an item ι =
[i, k, h] is defined as length(ι) = k − i + 1. Cor-
rect items of length 1 are the hypotheses of the
schema (of the form [i, i, i]) which are trivially valid.
We will prove that, if all correct items of length m
are valid for all 1 ≤ m < l, then items of length l
are also valid.

Let [i, k, i] be an item of length l in IES99 (thus,
l = k− i+1). If this item is correct, then it contains
a grounded dependency tree t such that yield(t) =
wi . . . wk and head(t) = wi.

By construction, the root of t is labelled wi. Let
wj be the rightmost daughter of wi in t. Since t
is projective, we know that the yield of wj must be
of the form wl . . . wk, where i < l ≤ j ≤ k. If
l < j, then wl is the leftmost transitive dependent of
wj in t, and if k > j, then we know that wk is the
rightmost transitive dependent of wj in t.

Let tj be the subtree of t rooted at wj . Let t1 be
the tree obtained from removing tj from t. Let t2 be

974



the tree obtained by removing all the children to the
right of wj from tj , and t3 be the tree obtained by re-
moving all the children to the left of wj from tj . By
construction, t1 belongs to a correct item [i, l− 1, i],
t2 belongs to a correct item [l, j, j] and t3 belongs to
a correct item [j, k, j]. Since these three items have
a length strictly less than l, by the inductive hypoth-
esis, they are valid. This allows us to prove that the
item [i, k, i] is also valid, since it can be obtained
from these valid items by the following inferences:
[i, l − 1, i], [l, j, j] ` [i, j, i] (by the L-Link step),
[i, j, i], [j, k, j] ` [i, k, i] (by the L-Combiner step).
This proves that all correct items of length l which
are of the form [i, k, i] are correct under the induc-
tive hypothesis. The same can be proved for items of
the form [i, k, k] by symmetric reasoning, thus prov-
ing that the ES99 parsing schema is correct.

5.2 YM03 is correct
In order to prove correctness of this parser, we fol-
low the same procedure as above. Soundness is
again trivial to verify. To prove completeness, we
use strong induction on the length of items, where
the length of an item [i, j] is defined as j − i + 1.

The induction step is proven by considering any
correct item [i, k] of length l > 2 (l = 2 is the base
case here since items of length 2 are generated by
the Initter step) and proving that it can be inferred
from valid antecedents of length less than l, so it is
valid. To show this, we note that, if l > 2, either
wi has at least a right dependent or wk has at least a
left dependent in the item. Supposing that wi has a
right dependent, if t1 and t2 are the trees rooted at wi
and wk in a forest in [i, k], we call wj the rightmost
daughter of wi and consider the following trees:

v = the subtree of t1 rooted at wj , u1 = the tree ob-
tained by removing v from t1, u2 = the tree obtained
by removing all children to the right of wj from v,
u3 = the tree obtained by removing all children to
the left of wj from v.

We observe that the forest {u1, u2} belongs to the
correct item [i, j], while {u3, t2} belongs to the cor-
rect item [j, k]. From these two items, we can obtain
[i, k] by using the L-Link step. Symmetric reason-
ing can be applied if wi has no right dependents but
wk has at least a left dependent, and analogously to
the case of the previous parser, we conclude that the
YM03 parsing schema is correct.

5.3 Eis96 is correct
By using the previous proofs and the relationships
between schemata that we explained earlier, it is
easy to prove that Eis96 is correct: soundness is,

as always, straightforward, and completeness can be
proven by using the properties of other algorithms.
Since the set of final items in Eis96 and ES99 are
the same, and the former is a step refinement of the
latter, the completeness of ES99 directly implies the
completeness of Eis96.

Alternatively, we can use YM03 to prove the cor-
rectness of Eis96 if we redefine the set of final items
in the latter to be of the form [0, n + 1, F, F ], which
are equally valid as final items since they always
contain parse trees. This idea can be applied to trans-
fer proofs of completeness across any refinement re-
lation.

6 Conclusions
We have defined a variant of Sikkel’s parsing
schemata formalism which allows us to represent
dependency parsing algorithms in a simple, declar-
ative way7. We have clarified relations between
parsers which were originally described very differ-
ently. For example, while Eisner presented his algo-
rithm as a dynamic programming algorithm which
combines spans into larger spans, Yamada and Mat-
sumoto’s works by sequentially executing parsing
actions that move a focus point in the input one po-
sition to the left or right, (possibly) creating a de-
pendency link. However, in the parsing schemata
for these algorithms we can see (and formally prove)
that they are related: one is a refinement of the other.

Parsing schemata are also a formal tool that can be
used to prove the correctness of parsing algorithms.
The relationships between dependency parsers can
be exploited to derive properties of a parser from
those of others, as we have seen in several examples.

Although the examples in this paper are cen-
tered in projective dependency parsing, the formal-
ism does not require projectivity and can be used to
represent nonprojective algorithms as well8. An in-
teresting line for future work is to use relationships
between schemata to find nonprojective parsers that
can be derived from existing projective counterparts.

7An alternative framework that formally describes some de-
pendency parsers is that of transition systems (McDonald and
Nivre, 2007). This model is based on parser configurations and
transitions, and has no clear relationship with the approach de-
scribed here.

8Note that spanning tree parsing algorithms based on edge-
factored models, such as the one by McDonald et al. (2005b)
are not constructive in the sense outlined in Section 2, so the
approach described here does not directly apply to them. How-
ever, other nonprojective parsers such as (Attardi, 2006) follow
a constructive approach and can be analysed deductively.

975



References
Miguel A. Alonso, Eric de la Clergerie, David Cabrero,

and Manuel Vilares. 1999. Tabular algorithms for
TAG parsing. In Proc. of the Ninth Conference on Eu-
ropean chapter of the Association for Computational
Linguistics, pages 150–157, Bergen, Norway. ACL.

Giuseppe Attardi. 2006. Experiments with a Multilan-
guage Non-Projective Dependency Parser. In Proc. of
the Tenth Conference on Natural Language Learning
(CoNLL-X), pages 166–170, New York, USA. ACL.

Cristina Barbero, Leonardo Lesmo, Vincenzo Lombarlo,
and Paola Merlo. 1998. Integration of syntactic
and lexical information in a hierarchical dependency
grammar. In Proc. of the Workshop on Dependency
Grammars, pages 58–67, ACL-COLING, Montreal,
Canada.

Sylvie Billot and Bernard Lang. 1989. The structure of
shared forest in ambiguous parsing. In Proc. of the
27th Annual Meeting of the Association for Computa-
tional Linguistics, pages 143–151, Vancouver, British
Columbia, Canada, June. ACL.

Michael John Collins. 1996. A new statistical parser
based on bigram lexical dependencies. In Proc. of
the 34th annual meeting on Association for Compu-
tational Linguistics, pages 184–191, Morristown, NJ,
USA. ACL.

Simon Corston-Oliver, Anthony Aue, Kevin Duh, and
Eric Ringger. 2006. Multilingual dependency pars-
ing using Bayes Point Machines. In Proc. of the main
conference on Human Language Technology Confer-
ence of the North American Chapter of the Association
of Computational Linguistics, pages 160–167, Morris-
town, NJ, USA. ACL.

Jacques Courtin and Damien Genthial. 1998. Parsing
with dependency relations and robust parsing. In Proc.
of the Workshop on Dependency Grammars, pages 88–
94, ACL-COLING, Montreal, Canada.

Michael A. Covington. 1990. A dependency parser for
variable-word-order languages. Technical Report AI-
1990-01, Athens, GA.

Jay Earley. 1970. An efficient context-free parsing algo-
rithm. Communications of the ACM, 13(2):94–102.

Jason Eisner and Giorgio Satta. 1999. Efficient pars-
ing for bilexical context-free grammars and head au-
tomaton grammars. In Proc. of the 37th annual meet-
ing of the Association for Computational Linguistics
on Computational Linguistics, pages 457–464, Mor-
ristown, NJ, USA. ACL.

Jason Eisner. 1996. Three new probabilistic models for
dependency parsing: An exploration. In Proc. of the
16th International Conference on Computational Lin-
guistics (COLING-96), pages 340–345, Copenhagen,
August.

Haim Gaifman. 1965. Dependency systems and phrase-
structure systems. Information and Control, 8:304–
337.

Carlos Gómez-Rodrı́guez, Jesús Vilares, and Miguel A.
Alonso. 2007. Compiling declarative specifications
of parsing algorithms. In Database and Expert Sys-
tems Applications, volume 4653 of Lecture Notes in
Computer Science, pages 529–538, Springer-Verlag.

David Hays. 1964. Dependency theory: a formalism and
some observations. Language, 40:511–525.

Sylvain Kahane, Alexis Nasr, and Owen Rambow. 1998.
Pseudo-projectivity: A polynomially parsable non-
projective dependency grammar. In COLING-ACL,
pages 646–652.

Vincenzo Lombardo and Leonardo Lesmo. 1996. An
Earley-type recognizer for dependency grammar. In
Proc. of the 16th conference on Computational linguis-
tics, pages 723–728, Morristown, NJ, USA. ACL.

Ryan McDonald, Koby Crammer, and Fernando Pereira.
2005a. Online large-margin training of dependency
parsers. In ACL ’05: Proc. of the 43rd Annual Meeting
on Association for Computational Linguistics, pages
91–98, Morristown, NJ, USA. ACL.

Ryan McDonald, Fernando Pereira, Kiril Ribarov and Jan
Hajič. 2005b. Non-projective dependency parsing us-
ing spanning tree algorithms. In HLT ’05: Proc. of
the conference on Human Language Technology and
Empirical Methods in Natural Language Processing,
pages 523–530. ACL.

Ryan McDonald and Joakim Nivre. 2007. Character-
izing the Errors of Data-Driven Dependency Parsing
Models. In Proc. of the 2007 Joint Conference on Em-
pirical Methods in Natural Language Processing and
Computational Natural Language Learning (EMNLP-
CoNLL), pages 122–131.

Joakim Nivre. 2006. Inductive Dependency Parsing
(Text, Speech and Language Technology). Springer-
Verlag New York, Inc., Secaucus, NJ, USA.

Stuart M. Shieber, Yves Schabes, and Fernando C.N.
Pereira. 1995. Principles and implementation of de-
ductive parsing. Journal of Logic Programming, 24:3–
36.

Klaas Sikkel. 1994. How to compare the structure of
parsing algorithms. In G. Pighizzini and P. San Pietro,
editors, Proc. of ASMICS Workshop on Parsing The-
ory. Milano, Italy, Oct 1994, pages 21–39.

Klaas Sikkel. 1997. Parsing Schemata — A Framework
for Specification and Analysis of Parsing Algorithms.
Texts in Theoretical Computer Science — An EATCS
Series. Springer-Verlag, Berlin/Heidelberg/New York.

Hiroyasu Yamada and Yuji Matsumoto. 2003. Statistical
dependency analysis with support vector machines. In
Proc. of 8th International Workshop on Parsing Tech-
nologies, pages 195–206.

976


