













































Optimal k-arization of Synchronous Tree-Adjoining Grammar


Proceedings of ACL-08: HLT, pages 604–612,
Columbus, Ohio, USA, June 2008. c©2008 Association for Computational Linguistics

Optimal k-arization of Synchronous Tree-Adjoining Grammar

Rebecca Nesson
School of Engineering
and Applied Sciences
Harvard University

Cambridge, MA 02138
nesson@seas.harvard.edu

Giorgio Satta
Department of

Information Engineering
University of Padua

I-35131 Padova, Italy
satta@dei.unipd.it

Stuart M. Shieber
School of Engineering
and Applied Sciences
Harvard University

Cambridge, MA 02138
shieber@seas.harvard.edu

Abstract

Synchronous Tree-Adjoining Grammar
(STAG) is a promising formalism for syntax-
aware machine translation and simultaneous
computation of natural-language syntax and
semantics. Current research in both of these
areas is actively pursuing its incorporation.
However, STAG parsing is known to be
NP-hard due to the potential for intertwined
correspondences between the linked nonter-
minal symbols in the elementary structures.
Given a particular grammar, the polynomial
degree of efficient STAG parsing algorithms
depends directly on the rank of the grammar:
the maximum number of correspondences that
appear within a single elementary structure.
In this paper we present a compile-time
algorithm for transforming a STAG into a
strongly-equivalent STAG that optimally
minimizes the rank, k, across the grammar.
The algorithm performs inO(|G|+ |Y | · L3G)
time where LG is the maximum number of
links in any single synchronous tree pair in
the grammar and Y is the set of synchronous
tree pairs of G.

1 Introduction

Tree-adjoining grammar is a widely used formal-
ism in natural-language processing due to its mildly-
context-sensitive expressivity, its ability to naturally
capture natural-language argument substitution (via
its substitution operation) and optional modifica-
tion (via its adjunction operation), and the existence
of efficient algorithms for processing it. Recently,
the desire to incorporate syntax-awareness into ma-
chine translation systems has generated interest in

the application of synchronous tree-adjoining gram-
mar (STAG) to this problem (Nesson, Shieber, and
Rush, 2006; Chiang and Rambow, 2006). In a par-
allel development, interest in incorporating seman-
tic computation into the TAG framework has led
to the use of STAG for this purpose (Nesson and
Shieber, 2007; Han, 2006b; Han, 2006a; Nesson
and Shieber, 2006). Although STAG does not in-
crease the expressivity of the underlying formalisms
(Shieber, 1994), STAG parsing is known to be NP-
hard due to the potential for intertwined correspon-
dences between the linked nonterminal symbols in
the elementary structures (Satta, 1992; Weir, 1988).
Without efficient algorithms for processing it, its po-
tential for use in machine translation and TAG se-
mantics systems is limited.

Given a particular grammar, the polynomial de-
gree of efficient STAG parsing algorithms depends
directly on the rank of the grammar: the maximum
number of correspondences that appear within a sin-
gle elementary structure. This is illustrated by the
tree pairs given in Figure 1 in which no two num-
bered links may be isolated. (By “isolated”, we
mean that the links can be contained in a fragment
of the tree that contains no other links and domi-
nates only one branch not contained in the fragment.
A precise definition is given in section 3.)

An analogous problem has long been known
to exist for synchronous context-free grammars
(SCFG) (Aho and Ullman, 1969). The task of
producing efficient parsers for SCFG has recently
been addressed by binarization or k-arization of
SCFG grammars that produce equivalent grammars
in which the rank, k, has been minimized (Zhang

604



A

B

C

D

w

A

B

C

DE F G

1

2

3

4

A

B C

D E F G

A

B C

D

2

3

1

4

1 2 3 4 2 4 31

w
!

w w
!

x x
!

y
!

y z z
!

A

B C

D 1

w

3 4

E 2

x

5 A

B C

D

1

3 4E

2

5

w
!

x
!

!1 : !2 : !3 :

Figure 1: Example of intertwined links that cannot be binarized. No two links can be isolated in both trees in a tree
pair. Note that in tree pair γ1, any set of three links may be isolated while in tree pair γ2, no group of fewer than four
links may be isolated. In γ3 no group of links smaller than four may be isolated.

S

V P

V

likes

red candies

aime

les bonbonsrouges

Det

NP!

S

V P

V NP!

NP

N

NP

NN!

N

Adj N!

N

Adj

S

NP V P

John V

likes

Jean

aime

S

NP V P

V

les

Det

NPNP

red

N

Adj

candies

N

bonbons

N

rouges

N

Adj

2

1

2

1 Jean

NPNP

John

NP! 1 NP! 1

likes

John candies

red

1 2

1

(a) (b) (c)

Figure 2: An example STAG derivation of the English/French sentence pair “John likes red candies”/“Jean aime les
bonbons rouges”. The figure is divided as follows: (a) the STAG grammar, (b) the derivation tree for the sentence
pair, and (c) the derived tree pair for the sentences.

and Gildea, 2007; Zhang et al., 2006; Gildea, Satta,
and Zhang, 2006). The methods for k-arization
of SCFG cannot be directly applied to STAG be-
cause of the additional complexity introduced by
the expressivity-increasing adjunction operation of
TAG. In SCFG, where substitution is the only avail-
able operation and the depth of elementary struc-
tures is limited to one, the k-arization problem re-
duces to analysis of permutations of strings of non-
terminal symbols. In STAG, however, the arbitrary
depth of the elementary structures and the lack of
restriction to contiguous strings of nonterminals in-
troduced by adjunction substantially complicate the
task.

In this paper we offer the first algorithm address-
ing this problem for the STAG case. We present
a compile-time algorithm for transforming a STAG
into a strongly-equivalent STAG that optimally min-
imizes k across the grammar. This is a critical mini-
mization because k is the feature of the grammar that
appears in the exponent of the complexity of parsing
algorithms for STAG. Following the method of Seki

et al. (1991), an STAG parser can be implemented
with complexity O(n4·(k+1) · |G|). By minimizing
k, the worst-case complexity of a parser instanti-
ated for a particular grammar is optimized. The k-
arization algorithm performs in O(|G|+ |Y | · L3G)
time where LG is the maximum number of links in
any single synchronous tree pair in the grammar and
Y is the set of synchronous tree pairs of G. By com-
parison, a baseline algorithm performing exhaustive
search requires O(|G|+ |Y | · L6G) time.

1

The remainder of the paper proceeds as follows.
In section 2 we provide a brief introduction to the
STAG formalism. We present the k-arization algo-
rithm in section 3 and an analysis of its complexity
in section 4. We prove the correctness of the algo-
rithm in section 5.

1In a synchronous tree pair with L links, there are O(L4)
pairs of valid fragments. It takes O(L) time to check if the two
components in a pair have the same set of links. Once the syn-
chronous fragment with the smallest number of links is excised,
this process iterates at most L times, resulting in time O(L6G).

605



D

E F

A

B

C

1

2

3 4

y z

5

H

I J2 3

1

NM 4

w
!

x
!

5

L

y
!

K

! :

x

G

z
!

n1 :

n2 :

n3 :

n4 :

n5 :

Figure 3: A synchronous tree pair containing frag-
ments αL = γL(n1, n2) and αR = γR(n3). Since
links(n1, n2) = links(n3) = { 2 , 4 , 5}, we can de-
fine synchronous fragment α = 〈αL, αR〉. Note also
that node n3 is a maximal node and node n5 is not.
σ(n1) = 2 5 5 3 3 2 4 4 ; σ(n3) = 2 5 5 4 4 2 .

2 Synchronous Tree-Adjoining Grammar

A tree-adjoining grammar (TAG) consists of a set of
elementary tree structures of arbitrary depth, which
are combined by substitution, familiar from context-
free grammars, or an operation of adjunction that is
particular to the TAG formalism. Auxiliary trees
are elementary trees in which the root and a frontier
node, called the foot node and distinguished by the
diacritic ∗, are labeled with the same nonterminalA.
The adjunction operation involves splicing an auxil-
iary tree in at an internal node in an elementary tree
also labeled with nonterminal A. Trees without a
foot node, which serve as a base for derivations, are
called initial trees. For further background, refer to
the survey by Joshi and Schabes (1997).

We depart from the traditional definition in nota-
tion only by specifying adjunction and substitution
sites explicitly with numbered links. Each link may
be used only once in a derivation. Operations may
only occur at nodes marked with a link. For sim-
plicity of presentation we provisionally assume that
only one link is permitted at a node. We later drop
this assumption.

In a synchronous TAG (STAG) the elementary
structures are ordered pairs of TAG trees, with a
linking relation specified over pairs of nonterminal
nodes. Each link has two locations, one in the left
tree in a pair and the other in the right tree. An ex-
ample of an STAG derivation including both substi-
tution and adjunction is given in Figure 2. For fur-
ther background, refer to the work of Shieber and
Schabes (1990) and Shieber (1994).

3 k-arization Algorithm

For a synchronous tree pair γ = 〈γL, γR〉, a frag-
ment of γL (or γR) is a complete subtree rooted at
some node n of γL, written γL(n), or else a subtree
rooted at n with a gap at node n′, written γL(n, n′);
see Figure 3 for an example. We write links(n) and
links(n, n′) to denote the set of links of γL(n) and
γL(n, n′), respectively. When we do not know the
root or gap nodes of some fragment αL, we also
write links(αL).

We say that a set of links Λ from γ can be iso-
lated if there exist fragments αL and αR of γL
and γR, respectively, both with links Λ. If this is
the case, we can construct a synchronous fragment
α = 〈αL, αR〉. The goal of our algorithm is to de-
compose γ into synchronous fragments such that the
maximum number of links of a synchronous frag-
ment is kept to a minimum, and γ can be obtained
from the synchronous fragments by means of the
usual substitution and adjunction operations. In or-
der to simplify the presentation of our algorithm we
assume, without any loss of generality, that all ele-
mentary trees of the source STAG have nodes with
at most two children.

3.1 Maximal Nodes

A node n of γL (or γR) is called maximal if
(i) links(n) 6= ∅, and (ii) it is either the root node
of γL or, for its parent node n′, we have links(n′) 6=
links(n). Note that for every node n′ of γL such
that links(n′) 6= ∅ there is always a unique maxi-
mal node n such that links(n′) = links(n). Thus,
for the purpose of our algorithm, we need only look
at maximal nodes as places for excising tree frag-
ments. We can show that the number of maxi-
mal nodes Mn in a subtree γL(n) always satisfies
|links(n)| ≤Mn ≤ 2× |links(n)| − 1.

Let n be some node of γL, and let l(n) be the
(unique) link impinging on n if such a link exists,
and l(n) = ε otherwise. We associate n with a
string σ(n), defined by a pre- and post-order traver-
sal of fragment γL(n). The symbols of σ(n) are the
links in links(n), viewed as atomic symbols. Given
a node n with p children n1, . . . , np, 0 ≤ p ≤ 2,
we define σ(n) = l(n)σ(n1) · · ·σ(np) l(n). See
again Figure 3 for an example. Note that |σ(n)| =
2× |links(n)|.

606



3

1
1

1

1

2
2

2

2

X X X X

R R
R

R

R

R

G
G

G

G

G

G
X !

X !

X !"

X !

X !
excise adjoin transform

!L :

n1 :

n2 :

Figure 4: A diagram of the tree transformation performed
when fragment γL(n1, n2) is removed. In this and the
diagrams that follow, patterned or shaded triangles rep-
resent segments of the tree that contain multiple nodes
and at least one link. Where the pattern or shading corre-
sponds across trees in a tree pair, the set of links contained
within those triangles are equivalent.

3.2 Excision of Synchronous Fragments

Although it would be possible to excise synchronous
fragments without creating new nonterminal nodes,
for clarity we present a simple tree transforma-
tion when a fragment is excised that leaves exist-
ing nodes intact. A schematic depiction is given in
Figure 4. In the figure, we demonstrate the exci-
sion process on one half of a synchronous fragment:
γL(n1, n2) is excised to form two new trees. The
excised tree is not processed further. In the exci-
sion process the root and gap nodes of the original
tree are not altered. The material between them is
replaced with a single new node with a fresh non-
terminal symbol and a fresh link number. This non-
terminal node and link form the adjunction or sub-
stitution site for the excised tree. Note that any link
impinging on the root node of the excised fragment
is by our convention included in the fragment and
any link impinging on the gap node is not.

To regenerate the original tree, the excised frag-
ment can be adjoined or substituted back into the
tree from which it was excised. The new nodes that
were generated in the excision may be removed and
the original root and gap nodes may be merged back
together retaining any impinging links, respectively.
Note that if there was a link on either the root or gap
node in the original tree, it is not lost or duplicated

1 1 0 0 0 0 0 0 0 0 1

2 0 1 0 0 0 0 1 0 1 0

5 0 0 1 1 0 0 0 0 0 0

5 0 0 1 1 0 0 0 0 0 0

3 0 0 0 0 0 0 0 1 1 0

3 0 0 0 0 0 0 0 1 1 0

2 0 1 0 0 0 0 1 0 0 0

4 0 0 0 0 1 1 0 0 0 0

4 0 0 0 0 1 1 0 0 0 0

1 1 0 0 0 0 0 0 0 0 1

1 2 5 5 4 4 2 3 3 1

0

Figure 5: Table π with synchronous fragment
〈γL(n1, n2), γR(n3)〉 from Figure 3 highlighted.

in the process.

3.3 Method

Let nL and nR be the root nodes of trees γL and γR,
respectively. We know that links(nL) = links(nR),
and |σ(nL)| = |σ(nR)|, the second string being a
rearrangement of the occurrences of symbols in the
first one. The main data structure of our algorithm is
a Boolean matrix π of size |σ(nL)|×|σ(nL)|, whose
rows are addressed by the occurrences of symbols in
σ(nL), in the given order, and whose columns are
similarly addressed by σ(nR). For occurrences of
links x1 , x2 , the element of π at a row addressed by
x1 and a column addressed by x2 is 1 if x1 = x2,
and 0 otherwise. Thus, each row and column of π
has exactly two non-zero entries. See Figure 5 for
an example.

For a maximal node n1 of γL, we let π(n1) de-
note the stripe of adjacent rows of π addressed by
substring σ(n1) of σ(nL). If n1 dominates n2 in γL,
we let π(n1, n2) denote the rows of π addressed by
σ(n1) but not by σ(n2). This forms a pair of hori-
zontal stripes in π. For nodes n3, n4 of γR, we sim-
ilarly define π(n3) and π(n3, n4) as vertical stripes
of adjacent columns. See again Figure 5.

Our algorithm is reported in Figure 6. For each
synchronous tree pair γ = 〈γL, γR〉 from the in-
put grammar, we maintain an agenda B with all
candidate fragments αL from γL having at least
two links. These fragments are processed greed-
ily in order of increasing number of links. The
function ISOLATE(), described in more detail be-

607



1: Function KARIZE(G) {G a binary STAG}
2: G′ ← STAG with empty set of synch trees;
3: for all γ = 〈γL, γR〉 in G do
4: init π and B;
5: while B 6= ∅ do
6: αL ← next fragment from B;
7: αR ← ISOLATE(αL, π, γR);
8: if αR 6= null then
9: add 〈αL, αR〉 to G′;

10: γ ← excise 〈αL, αR〉 from γ;
11: update π and B;
12: add γ to G′;
13: return G′

Figure 6: Main algorithm.

low, looks for a right fragment αR with the same
links as αL. Upon success, the synchronous frag-
ment α = 〈αL, αR〉 is added to the output grammar.
Furthermore, we excise α from γ and update data
structures π and B. The above process is iterated
until B becomes empty. We show in section 5 that
this greedy strategy is sound and complete.

The function ISOLATE() is specified in Figure 7.
We take as input a left fragment αL, which is asso-
ciated with one or two horizontal stripes in π, de-
pending on whether αL has a gap node or not. The
left boundary of αL in π is the index x1 of the col-
umn containing the leftmost occurrence of a 1 in the
horizontal stripes associated with αL. Similarly, the
right boundary of αL in π is the index x2 of the col-
umn containing the rightmost occurrence of a 1 in
these stripes. We retrieve the shortest substring σ(n)
of σ(nR) that spans over indices x1 and x2. This
means that n is the lowest node from γR such that
the links of αL are a subset of the links of γR(n).

If the condition at line 3 is satisfied, all of the ma-
trix entries of value 1 that are found from column
x1 to column x2 fall within the horizontal stripes
associated with αL. In this case we can report the
right fragment αR = γR(n). Otherwise, we check
whether the entries of value 1 that fall outside of
the two horizontal stripes in between columns x1
and x2 occur within adjacent columns, say from col-
umn x3 ≥ x1 to column x4 ≤ x2. In this case,
we check whether there exists some node n′ such
that the substring of σ(n) from position x3 to x4 is

1: Function ISOLATE(αL, π, γR)
2: select n ∈ γR such that σ(n) is the shortest

string within σ(nR) including left/right bound-
aries of αL in π;

3: if |σ(n)| = 2× |links(αL)| then
4: return γR(n);
5: select n′ ∈ γR such that σ(n′) is the gap string

within σ(n) for which links(n) − links(n′) =
links(αL);

6: if n′ is not defined then
7: return null; {more than one gap}
8: return γR(n, n′);

Figure 7: Find synchronous fragment.

an occurrence of string σ(n′). This means that n′

is the gap node, and we report the right fragment
αL = γR(n, n′). See again Figure 5.

We now drop the assumption that only one link
may impinge on a node. When multiple links im-
pinge on a single node n, l(n) is an arbitrary order
over those links. In the execution of the algorithm,
any stripe that contains one link in l(n) it must in-
clude every link in l(n). This prevents the excision
of a proper subset of the links at any node. This pre-
serves correctness because excising any proper sub-
set would impose an order over the links at n that
is not enforced in the input grammar. Because the
links at a node are treated as a unit, the complexity
of the algorithm is not affected.

4 Complexity

We discuss here an implementation of the algo-
rithm of section 3 resulting in time complexity
O(|G|+ |Y | · L3G), where Y is the set of syn-
chronous tree pairs of G and LG is the maximum
number of links in a synchronous tree pair in Y .

Consider a synchronous tree pair γ = 〈γL, γR〉
with L links. If M is the number of maximal nodes
in γL or γR, we have M = Θ(L) (Section 3.1). We
implement the sparse table π inO(L) space, record-
ing for each row and column the indices of its two
non-zero entries. We also assume that we can go
back and forth between maximal nodes n and strings
σ(n) in constant time. Here each σ(n) is represented
by its boundary positions within σ(nL) or σ(nR),
nL and nR the root nodes of γL and γR, respectively.

608



At line 2 of the function ISOLATE() (Figure 7) we
retrieve the left and right boundaries by scanning the
rows of π associated with input fragment αL. We
then retrieve node n by visiting all maximal nodes
of γL spanning these boundaries. Under the above
assumptions, this can be done in time O(L). In a
similar way we can implement line 5, resulting in
overall run time O(L) for function ISOLATE().

In the function KARIZE() (Figure 6) we use buck-
ets Bi, 1 ≤ i ≤ L, where each Bi stores the candi-
date fragments αL with |links(αL)| = i. To populate
these buckets, we first process fragments γL(n) by
visiting bottom up the maximal nodes of γL. The
quantity |links(n)| is computed from the quantities
|links(ni)|, where ni are the highest maximal nodes
dominated by n. (There are at most two such nodes.)
Fragments γL(n, n′) can then be processed using
the relation |links(n, n′)| = |links(n)| − |links(n′)|.
In this way each fragment is processed in constant
time, and population of all the buckets takes O(L2)
time.

We now consider the while loop at lines 5 to 11 in
function KARIZE(). For a synchronous tree pair γ,
the loop iterates once for each candidate fragment
αL in some bucket. We have a total of O(L2) it-
erations, since the initial number of candidates in
the buckets is O(L2), and the possible updating of
the buckets after a synchronous fragment is removed
does not increase the total size of all the buckets. If
the links in αL cannot be isolated, one iteration takes
time O(L) (the call to function ISOLATE()). If the
links in αL can be isolated, then we need to restruc-
ture π and to repopulate the buckets. The former
can be done in time O(L) and the latter takes time
O(L2), as already discussed. Crucially, the updat-
ing of π and the buckets takes place no more than
L − 1 times. This is because each time we excise
a synchronous fragment, the number of links in γ is
reduced by at least one.

We conclude that function KARIZE() takes time
O(L3) for each synchronous tree γ, and the total
running time is O(|G|+ |Y | · L3G), where Y is the
set of synchronous tree pairs of G. The term |G| ac-
counts for the reading of the input, and dominates
the complexity of the algorithm only in case there
are very few links in each synchronous tree pair.

A

B C

D 1

w

3 4

E 2

x

5

B

D 1

w

3

6

n1 :

n2 :

n3 :

n4 :

! : !
!
:

A
!

A

Figure 8: In γ links 3 and 5 cannot be isolated because
the fragment would have to contain two gaps. However,
after the removal of fragment γ(n1, n2), an analogous
fragment γ′(n3, n4) may be removed.

5 Proof of Correctness

The algorithm presented in the previous sections
produces an optimal k-arization for the input gram-
mar. In this section we sketch a proof of correctness
of the strategy employed by the algorithm.2

The k-arization strategy presented above is
greedy in that it always chooses the excisable frag-
ment with the smallest number of links at each step
and does not perform any backtracking. We must
therefore show that this process cannot result in a
non-optimal solution. If fragments could not overlap
each other, this would be trivial to show because the
excision process would be confluent. If all overlap-
ping fragments were cases of complete containment
of one fragment within another, the proof would also
be trivial because the smallest-to-largest excision or-
der would guarantee optimality. However, it is pos-
sible for fragments to partially overlap each other,
meaning that the intersection of the set of links con-
tained in the two fragments is non-empty and the dif-
ference between the set of links in one fragment and
the other is also non-empty. Overlapping fragment
configurations are given in Figure 9 and discussed in
detail below.

The existence of partially overlapping fragments
complicates the proof of optimality for two reasons.
First, the excision of a fragment α that is partially
overlapped with another fragment β necessarily pre-
cludes the excision of β at a later stage in the ex-

2Note that the soundness of the algorithm can be easily veri-
fied from the fact that the removal of fragments can be reversed
by performing standard STAG adjunction and substitution oper-
ations until a single STAG tree pair is produced. This tree pair
is trivially homomorphic to the original tree pair and can easily
be mapped to the original tree pair.

609



(1, 1!)

! !

A

B

C

D

n1 :

n2 :

n3 :

n4 :

A

B C

n5 :

n6 : n7 :

A

B

C D

n8 :

n9 :

n10 : n11 :

(2) (3)

Figure 9: The four possible configurations of overlapped
fragments within a single tree. For type 1, let α =
γ(n1, n3) and β = γ(n2, n4). The roots and gaps of the
fragments are interleaved. For type 1′, let α = γ(n1, n3)
and β = γ(n2). The root of β dominates the gap of α.
For type 2, let α = γ(n5, n6) and β = γ(n5, n7). The
fragments share a root and have gap nodes that do not
dominate each other. For type 3 let α = γ(n8, n10) and
β = γ(n9, n11). The root of α dominates the root of β,
both roots dominate both gaps, but neither gap dominates
the other.

cision process. Second, the removal of a fragment
may cause a previously non-isolatable set of links to
become isolatable, effectively creating a new frag-
ment that may be advantageous to remove. This is
demonstrated in Figure 8. These possibilities raise
the question of whether the choice between remov-
ing fragments α and β may have consequences at a
later stage in the excision process. We demonstrate
that this choice cannot affect the k found for a given
grammar.

We begin by sketching the proof of a lemma that
shows that removal of a fragment β that partially
overlaps another fragment α always leaves an anal-
ogous fragment that may be removed.

5.1 Validity Preservation

Consider a STAG tree pair γ containing the set of
links Λ and two synchronous fragments α and β
with α containing links links(α) and β containing
links(β) (links(α), links(β) ( Λ).

If α and β do not overlap, the removal of β is
defined as validity preserving with respect to α.

If α and β overlap, removal of β from γ is valid-
ity preserving with respect to α if after the removal
there exists a valid synchronous fragment (contain-
ing at most one gap on each side) that contains all
and only the links (links(α)− links(β))∪{x}where
x is the new link added to γ.

remove α

remove β

A

B

C

D

E

F G

n1 :

n2 :

n3 :

n4 :

n5 :

n6 : n7 :

An1 : En5 :

Cn3 :

x x

Dn4 :

Fn6 :

H I

An1 :

Bn2 :

J x

Dn4 :

En5 :

K x

Dn4 :

Figure 10: Removal from a tree pair γ containing type 1–
type 2 fragment overlap. The fragment α is represented
by the horizonal-lined pieces of the tree pair. The frag-
ment β is represented by the vertical-lined pieces of the
tree pair. Cross-hatching indicates the overlapping por-
tion of the two fragments.

We prove a lemma that removal of any syn-
chronous fragment from an STAG tree pair is va-
lidity preserving with respect to all of the other syn-
chronous fragments in the tree pair.

It suffices to show that for two arbitrary syn-
chronous fragments α and β, the removal of β is
validity preserving with respect to α. We show this
by examination of the possible configurations of α
and β.

Consider the case in which β is fully contained
within α. In this case links(β) ( links(α). The re-
moval of β leaves the root and gap of α intact in both
trees in the pair, so it remains a valid fragment. The
new link is added at the new node inserted where
β was removed. Since β is fully contained within
α, this node is below the root of α but not below
its gap. Thus, the removal process leaves α with the
links (links(α)−links(β))∪{x}, where x is the link
added in the removal process; the removal is validity
preserving.

Synchronous fragments may partially overlap in
several different ways. There are four possible con-
figurations for an overlapped fragment within a sin-
gle tree, depicted in Figure 9. These different single-
tree overlap types can be combined in any way to
form valid synchronous fragments. Due to space
constraints, we consider two illustrative cases and
leave the remainder as an exercise to the reader.

An example of removing fragments from
a tree set containing type 1–type 2 over-
lapped fragments is given in Figure 10.
Let α = 〈γL(n1, n3), γR(n5, n6)〉. Let

610



β = 〈γL(n2, n4), γR(n5, n7)〉. If α is re-
moved, the validity preserving fragment for β is
〈γ′L(n1, n4), γ

′
R(n5)〉. It contains the links in the

vertical-lined part of the tree and the new link x .
This forms a valid fragment because both sides con-
tain at most one gap and both contain the same set
of links. In addition, it is validity preserving for β
because it contains exactly the set of links that were
in links(β) and not in links(α) plus the new link
x . If we instead choose to remove β, the validity
preserving fragment for α is 〈γ′L(n1, n4), γ

′
R(n5)〉.

The links in each side of this fragment are the same,
each side contains at most one gap, and the set of
links is exactly the set left over from links(α) once
links(β) is removed plus the newly generated link x .

An example of removing fragments from a tree
set containing type 1′–type 3 (reversed) overlapped
fragments is given in Figure 11. If α is re-
moved, the validity preserving fragment for β is
〈γ′L(n1), γ

′
R(n4)〉. If β is removed, the validity pre-

serving fragment for α is 〈γ′L(n1, n8), γ
′
R(n4)〉.

Similar reasoning follows for all remaining types
of overlapped fragments.

5.2 Proof Sketch
We show that smallest-first removal of fragments is
optimal. Consider a decision point at which a choice
is made about which fragment to remove. Call the
size of the smallest fragments at this pointm, and let
the set of fragments of size m be X with α, β ∈ X .

There are two cases to consider. First, consider
two partially overlapped fragments α ∈ X and
δ /∈ X . Note that |links(α)| < |links(δ)|. Valid-
ity preservation of α with respect to δ guarantees
that δ or its validity preserving analog will still be
available for excision after α is removed. Excising
δ increases k more than excising α or any fragment
that removal of α will lead to before δ is considered.
Thus, removal of δ cannot result in a smaller value
for k if it is removed before α rather than after α.

Second, consider two partially overlapped frag-
ments α, β ∈ X . Due to the validity preservation
lemma, we may choose arbitrarily between the frag-
ments in X without jeopardizing our ability to later
remove other fragments (or their validity preserving
analogs) in that set. Removal of fragment α cannot
increase the size of any remaining fragment.

Removal of α or β may generate new fragments

remove α
remove β

A

B

C

n1 :

n2 :

n3 :

E

F G

n5 :

n6 : n7 :

Dn4 : An1 :

Cn3 :

xH
En5 :

x

Fn6 :

I

Dn4 : An1 :

Bn2 :

xJ!

Dn4 :

K x

Gn7 :

n8 :

Figure 11: Removal from a tree pair γ containing a type
1′–type 3 (reversed) fragment overlap. The fragment α is
represented by the horizontal lined pieces of the tree pair.
The fragment β is represented by the vertical-lined pieces
of the tree pair. Cross-hatching indicates the overlapping
portion of the two fragments.

that were not previously valid and may reduce the
size of existing fragments that it overlaps. In addi-
tion, removal of αmay lead to availability of smaller
fragments at the next removal step than removal of β
(and vice versa). However, since removal of either α
or β produces a k of size at leastm, the later removal
of fragments of size less than m cannot affect the k
found by the algorithm. Due to validity preservation,
removal of any of these smaller fragments will still
permit removal of all currently existing fragments or
their analogs at a later step in the removal process.

If the removal of α generates a new fragment δ of
size larger thanm all remaining fragments inX (and
all others smaller than δ) will be removed before δ
is considered. Therefore, if removal of β generates a
new fragment smaller than δ, the smallest-first strat-
egy will properly guarantee its removal before δ.

6 Conclusion

In order for STAG to be used in machine translation
and other natural-language processing tasks it must
be possible to process it efficiently. The difficulty in
parsing STAG stems directly from the factor k that
indicates the degree to which the correspondences
are intertwined within the elementary structures of
the grammar. The algorithm presented in this pa-
per is the first method available for k-arizing a syn-
chronous TAG grammar into an equivalent grammar
with an optimal value for k. The algorithm operates
offline and requires only O(|G|+ |Y | · L3G) time.
Both the derivation trees and derived trees produced
are trivially homomorphic to those that are produced
by the original grammar.

611



References

Aho, Alfred V. and Jeffrey D. Ullman. 1969. Syntax di-
rected translations and the pushdown assembler. Jour-
nal of Computer and System Sciences, 3(1):37–56.

Chiang, David and Owen Rambow. 2006. The hid-
den TAG model: synchronous grammars for parsing
resource-poor languages. In Proceedings of the 8th
International Workshop on Tree Adjoining Grammars
and Related Formalisms (TAG+ 8), pages 1–8.

Gildea, Daniel, Giorgio Satta, and Hao Zhang. 2006.
Factoring synchronous grammars by sorting. In Pro-
ceedings of the International Conference on Compu-
tational Linguistics and the Association for Computa-
tional Linguistics (COLING/ACL-06), July.

Han, Chung-Hye. 2006a. Pied-piping in relative clauses:
Syntax and compositional semantics based on syn-
chronous tree adjoining grammar. In Proceedings
of the 8th International Workshop on Tree Adjoining
Grammars and Related Formalisms (TAG+ 8), pages
41–48, Sydney, Australia.

Han, Chung-Hye. 2006b. A tree adjoining grammar
analysis of the syntax and semantics of it-clefts. In
Proceedings of the 8th International Workshop on Tree
Adjoining Grammars and Related Formalisms (TAG+
8), pages 33–40, Sydney, Australia.

Joshi, Aravind K. and Yves Schabes. 1997. Tree-
adjoining grammars. In G. Rozenberg and A. Sa-
lomaa, editors, Handbook of Formal Languages.
Springer, pages 69–124.

Nesson, Rebecca and Stuart M. Shieber. 2006. Sim-
pler TAG semantics through synchronization. In Pro-
ceedings of the 11th Conference on Formal Grammar,
Malaga, Spain, 29–30 July.

Nesson, Rebecca and Stuart M. Shieber. 2007. Extrac-
tion phenomena in synchronous TAG syntax and se-
mantics. In Proceedings of Syntax and Structure in
Statistical Translation (SSST), Rochester, NY, April.

Nesson, Rebecca, Stuart M. Shieber, and Alexander
Rush. 2006. Induction of probabilistic synchronous
tree-insertion grammars for machine translation. In
Proceedings of the 7th Conference of the Associa-
tion for Machine Translation in the Americas (AMTA
2006), Boston, Massachusetts, 8-12 August.

Satta, Giorgio. 1992. Recognition of linear context-free
rewriting systems. In Proceedings of the 10th Meet-
ing of the Association for Computational Linguistics
(ACL92), pages 89–95, Newark, Delaware.

Seki, H., T. Matsumura, M. Fujii, and T. Kasami. 1991.
On multiple context-free grammars. Theoretical Com-
puter Science, 88:191–229.

Shieber, Stuart M. 1994. Restricting the weak-generative
capacity of synchronous tree-adjoining grammars.

Computational Intelligence, 10(4):371–385, Novem-
ber.

Shieber, Stuart M. and Yves Schabes. 1990. Syn-
chronous tree adjoining grammars. In Proceedings of
the 13th International Conference on Computational
Linguistics (COLING ’90), Helsinki, August.

Weir, David. 1988. Characterizing mildly context-
sensitive grammar formalisms. PhD Thesis, Depart-
ment of Computer and Information Science, Univer-
sity of Pennsylvania.

Zhang, Hao and Daniel Gildea. 2007. Factorization of
synchronous context-free grammars in linear time. In
NAACL Workshop on Syntax and Structure in Statisti-
cal Translation (SSST), April.

Zhang, Hao, Liang Huang, Daniel Gildea, and Kevin
Knight. 2006. Synchronous binarization for ma-
chine translation. In Proceedings of the Human Lan-
guage Technology Conference/North American Chap-
ter of the Association for Computational Linguistics
(HLT/NAACL).

612


