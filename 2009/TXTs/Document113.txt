













































A Polynomial-Time Parsing Algorithm for TT-MCTAG


Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 994–1002,
Suntec, Singapore, 2-7 August 2009. c©2009 ACL and AFNLP

A Polynomial-Time Parsing Algorithm for TT-MCTAG

Laura Kallmeyer
Collaborative Research Center 441

Universität Tübingen
Tübingen, Germany

lk@sfs.uni-tuebingen.de

Giorgio Satta
Department of Information Engineering

University of Padua
Padova, Italy

satta@dei.unipd.it

Abstract

This paper investigates the class of Tree-
Tuple MCTAG with Shared Nodes, TT-
MCTAG for short, an extension of Tree
Adjoining Grammars that has been pro-
posed for natural language processing, in
particular for dealing with discontinuities
and word order variation in languages such
as German. It has been shown that the uni-
versal recognition problem for this formal-
ism is NP-hard, but so far it was not known
whether the class of languages generated
by TT-MCTAG is included in PTIME. We
provide a positive answer to this ques-
tion, using a new characterization of TT-
MCTAG.

1 Introduction

For a large range of linguistic phenomena, exten-
sions of Tree Adjoining Grammars (Joshi et al.,
1975), or TAG for short, have been proposed based
on the idea of separating the contribution of a lex-
ical item into several components. Instead of sin-
gle trees, these grammars contain (multi-)sets of
trees. Examples are tree-local and set-local mul-
ticomponent TAG (Joshi, 1985; Weir, 1988), MC-
TAG for short, non-local MCTAG with dominance
links (Becker et al., 1991), Vector-TAG with dom-
inance links (Rambow, 1994) and, more recently,
Tree-Tuple MCTAG with Shared Nodes (Lichte,
2007)), or TT-MCTAG for short.

For some of the above formalisms the word
recognition problem is NP-hard. This has been
shown for non-local MCTAG (Rambow and Satta,
1992), even in the lexicalized case (Champollion,
2007). Some others generate only polynomial lan-
guages but their generative capacity is too limited
to deal with all natural language phenomena. This
has been argued for tree-local and even set-local
MCTAG on the basis of scrambling data from lan-

guages such as German (Becker et al., 1992; Ram-
bow, 1994).

In this paper, we focus on TT-MCTAG (Lichte,
2007). So far, it has been shown that the univer-
sal recognition problem for TT-MCTAG is NP-
hard (Søgaard et al., 2007). A restriction on TT-
MCTAG has been proposed in (Kallmeyer and
Parmentier, 2008): with such a restriction, the uni-
versal recognition problem is still NP-hard, but
the class of generated languages is included in
PTIME, i.e., all these languages can be recognized
in deterministic polynomial time. In this paper, we
address the question of whether for general TT-
MCTAG, i.e., TT-MCTAG without the constraint
from (Kallmeyer and Parmentier, 2008), the class
of generated languages is included in PTIME. We
provide a positive answer to this question.

The TT-MCTAG definition from (Lichte, 2007;
Kallmeyer and Parmentier, 2008) imposes a con-
dition on the way different tree components from a
tree tuple in the grammar combine with each other.
This condition is formulated in terms of mapping
between argument and head trees, i.e., in order to
test such a condition one has to guess some group-
ing of the tree components used in a derivation into
instances of tree tuples from the grammar. This re-
sults in a combinatorial explosion of parsing anal-
yses. In order to obtain a polynomial parsing al-
gorithm, we need to avoid this effect.

On this line, we propose an alternative charac-
terization of TT-MCTAG that only requires (i) a
counting of tree components and (ii) the check of
some local conditions on these counts. This allows
for parsing in polynomial deterministic time.

TT-MCTAG uses so-called ‘parallel unordered’
rewriting. The first polynomial time parsing
results on this class were presented in (Ram-
bow and Satta, 1994; Satta, 1995) for some
string-based systems, exploiting counting tech-
niques closely related to those we use in this pa-
per. In contrast to string-based rewriting, the tree

994



rewriting formalisms we consider here are struc-
turally more complex and require specializations
of the above techniques. Polynomial parsing re-
sults for tree rewriting systems based on paral-
lel unordered rewriting have also been reported
in (Rambow, 1994; Rambow et al., 1995). How-
ever, in the approach proposed by these authors,
tree-based grammars are first translated into equiv-
alent string-based systems, and the result is again
provided on the string domain.

2 Tree Adjoining Grammars

Tree Adjoining Grammars (Joshi et al., 1975) are
a formalism based on tree rewriting. We briefly
summarize here the relevant definitions and refer
the reader to (Joshi and Schabes, 1997) for a more
complete introduction.

Definition 1 A Tree Adjoining Grammar
(TAG) is a tuple G = (VN , VT , S, I,A) where
VN and VT are disjoint alphabets of non-terminal
and terminal symbols, respectively, S ∈ VN is the
start symbol, and I and A are finite sets of initial
and auxiliary trees, respectively. 2

Trees in I ∪A are called elementary trees. The
internal nodes in the elementary trees are labeled
with non-terminal symbols, the leaves with non-
terminal or terminal symbols. As a special prop-
erty, each auxiliary tree β has exactly one of its
leaf nodes marked as the foot node, having the
same label as the root. Such a node is denoted by
Ft(β). Leaves with non-terminal labels that are
not foot nodes are called substitution nodes.

In a TAG, larger trees can be derived from the
elementary trees by subsequent applications of the
operations substitution and adjunction. The sub-
stitution operation replaces a substitution node η
with an initial tree having root node with the same
label as η. The adjunction operation replaces
an internal node η in a previously derived tree γ
with an auxiliary tree β having root node with the
same label as η. The subtree of γ rooted at η is
then placed below the foot node of β. Only inter-
nal nodes can allow for adjunction, adjunction at
leaves is not possible. See figure 1 for an example
of a tree derivation.

Usually, a TAG comes with restrictions on the
two operations, specified at each node η by sets
Sbst(η) and Adj (η) listing all elementary trees
that can be substituted or adjoined, respectively.
Furthermore, adjunction at η might be obligatory.

NP

John

S

NP VP

V

laughs

VP

ADV VP∗

always

derived tree:
S

NP VP

John ADV VP

always V

laughs

derivation tree:
laugh

1 2

john always

Figure 1: TAG derivation for John always laughs

TAG derivations are represented by derivation
trees that record the history of how the elemen-
tary trees are put together. A derivation tree is
an unordered tree whose nodes are labeled with
elements in I ∪ A and whose edges are labeled
with Gorn addresses of elementary trees.1 Each
edge in a derivation tree stands for an adjunction
or a substitution. E.g., the derivation tree in fig-
ure 1 indicates that the elementary tree for John is
substituted for the node at address 1 and always is
adjoined at node address 2.

In the following, we write a derivation tree D
as a directed graph 〈V,E, r〉 where V is the set of
nodes, E ⊂ V × V is the set of arcs and r ∈ V is
the root. For every v ∈ V , Lab(v) gives the node
label and for every 〈v1, v2〉 ∈ E, Lab(〈v1, v2〉)
gives the edge label.

A derived tree is the result of carrying out the
substitutions and the adjunctions in a derivation
tree, i.e., the derivation tree describes uniquely the
derived tree; see again figure 1.

3 TT-MCTAG

3.1 Introduction to TT-MCTAG

For a range of linguistic phenomena, multicompo-
nent TAG (Weir, 1988) have been proposed, also
called MCTAG for short. The underlying motiva-
tion is the desire to split the contribution of a single
lexical item (e.g., a verb and its arguments) into
several elementary trees. An MCTAG consists of
(multi-)sets of elementary trees, called tree sets.
If an elementary tree from some set is used in a
derivation, then all of the remaining trees in the
set must be used as well. Several variants of MC-
TAGs can be found the literature, differing on the

1In this convention, the root address is ε and the jth child
of a node with address p has address p · j.

995



specific definition of the derivation process.
The particular MCTAG variant we are con-

cerned with is Tree-Tuple MCTAG with Shared
Nodes, TT-MCTAG (Lichte, 2007). TT-MCTAG
were introduced to deal with free word order phe-
nomena in languages such as German. An exam-
ple is (1) where the argument es of reparieren pre-
cedes the argument der Mann of versucht and is
not adjacent to the predicate it depends on.

(1) ... dass es der Mann zu reparieren versucht
... that it the man to repair tries
‘... that the man tries to repair it’

A TT-MCTAG is slightly different from stan-
dard MCTAGs since each elementary tree set con-
tains one specially marked lexicalized tree called
the head, and all of the remaining trees in the set
function as arguments of the head. Furthermore, in
a TT-MCTAG derivation the argument trees must
either adjoin directly to their head tree, or they
must be linked in the derivation tree to an elemen-
tary tree that attaches to the head tree, by means
of a chain of adjunctions at root nodes. In other
words, in the corresponding TAG derivation tree,
the head tree must dominate the argument trees in
such a way that all positions on the path between
them, except the first one, must be labeled by ε.
This captures the notion of adjunction under node
sharing from (Kallmeyer, 2005).2

Definition 2 A TT-MCTAG is a tuple G = (VN ,
VT , S, I,A,T ) where GT = (VN , VT , S, I,A) is
an underlying TAG and T is a finite set of tree
tuples of the form Γ = 〈γ, {β1, . . . , βr}〉 where
γ ∈ (I ∪ A) has at least one node with a terminal
label, and β1, . . . , βn ∈ A. 2

For each Γ = 〈γ, {β1, . . . , βr}〉 ∈ T , we call γ
the head tree and the βj’s the argument trees.
We informally say that γ and the βj’s belong to Γ,
and write |Γ| = r + 1.

As a remark, an elementary tree γ from the un-
derlying TAG GT can be found in different tree tu-
ples in G, or there could even be multiple instances
of such a tree within the same tree tuple Γ. In these
cases, we just treat these tree instances as distinct
trees that are isomorphic and have identical labels.

2The intuition is that, if a tree γ′ adjoins to some γ, its
root in the resulting derived tree somehow belongs both to γ
and γ′ or, in other words, is shared by them. A further tree β
adjoining to this node can then be considered as adjoining to
γ, not only to γ′ as in standard TAG. Note that we assume that
foot nodes do not allow adjunctions, otherwise node sharing
would also apply to them.

For a given argument tree β in Γ, h(β) denotes the
head of β in Γ. For a given γ ∈ I∪A, a(γ) denotes
the set of argument trees of γ, if there are any, or
the empty set otherwise. Furthermore, for a given
TT-MCTAG G, H(G) is the set of head trees and
A(G) is the set of argument trees. Finally, a node
v in a derivation tree for G with Lab(v) = γ is
called a γ-node.

Definition 3 Let G = (VN , VT , S, I,A,T ) be
some TT-MCTAG. A derivation tree D =
〈V,E, r〉 in the underlying TAG GT is licensed in
G if and only if the following conditions (MC) and
(SN-TTL) are both satisfied.

• (MC): For all Γ from G and for all γ1, γ2
in Γ, we have |{v | v ∈ V, Lab(v) = γ1}| =
|{v | v ∈ V, Lab(v) = γ2}|.

• (SN-TTL): For all β ∈ A(G) and n ≥ 1,
let v1, . . . , vn ∈ V be pairwise different
h(β)-nodes, 1 ≤ i ≤ n. Then there are
pairwise different β-nodes u1, . . . , un ∈ V ,
1 ≤ i ≤ n. Furthermore, for 1 ≤ i ≤
n, either 〈vi, ui〉 ∈ E, or else there are
ui,1, . . . , ui,k, k ≥ 2, with auxiliary tree la-
bels, such that ui = ui,k, 〈vi, ui,1〉 ∈ E and,
for 1 ≤ j ≤ k − 1, 〈ui,j, ui,j+1〉 ∈ E with
Lab(〈ui,j , ui,j+1〉) = ε. 2

The separation between (MC) and (SN-TTL)
in definition 3 is motivated by the desire to
separate the multicomponent property that TT-
MCTAG shares with a range of related formalisms
(e.g., tree-local and set-local MCTAG, Vector-
TAG, etc.) from the notion of tree-locality with
shared nodes that is peculiar to TT-MCTAG.

Figure 2 shows a TT-MCTAG derivation for (1).
Here, the NPnom auxiliary tree adjoins directly to
versucht (its head) while the NPacc tree adjoins to
the root of a tree that adjoins to the root of a tree
that adjoins to reparieren.

TT-MCTAG can generate languages that, in
a strong sense, cannot be generated by Linear
Context-Free Rewriting Systems (Vijay-Shanker
et al., 1987; Weir, 1988), or LCFRS for
short. An example is the language of all strings
π(n[1] . . . n[m])v[1] . . . v[m] with m ≥ 1, π a per-
mutation, and n[i] = n is a nominal argument of
v[i] = v for 1 ≤ i ≤ m, i.e., these occurrences
come from the same tree set in the grammar. Such
a language has been proposed as an abstract de-
scription of the scrambling phenomenon as found
in German and other free word order languages,

996



*

VP

VP∗ versucht
,

(

VP

NPnom VP
∗

) + *

NPnom

der Mann
, {}

+

*

VP

zu reparieren
,

(

VP

NPacc VP
∗

) + *

NPacc

es
, {}

+

derivation tree:
reparieren

ε
versucht

ε
NPnom

1 ε
Mann NPacc

1
es

Figure 2: TT-MCTAG derivation of (1)

*

α VP

v
,

(

β1 VPv=−

n VP∗NA

)+

*

β2 VP

v VP∗NAv=+
,

(

β3 VPv=−

n VP∗NA

)+

Figure 3: TT-MCTAG

and cannot be generated by a LCFRS (Becker et
al., 1992; Rambow, 1994). Figure 3 reports a TT-
MCTAG for this language.

Concerning the other direction, at the time of
writing it is not known whether there are lan-
guages generated by LCFRS but not by TT-
MCTAG. It is well known that LCFRS is closed
under the finite-copy operator. This means that,
for any fixed k > 1, if L is generated by a LCFRS
then the language {w |w = uk, u ∈ L} can
also be generated by a LCFRS. We conjecture that
TT-MCTAG does not have such a closure prop-
erty. However, from a first inspection of the MC-
TAG analyses proposed for natural languages (see
Chen-Main and Joshi (2007) for an overview), it
seems that there are no important natural language
phenomena that can be described by LCFRS and
not by TT-MCTAG. Any construction involving
some kind of component stacking along the VP
projection such as subject-auxiliary inversion can
be modelled with TT-MCTAG. Unbounded extra-
position phenomena cannot be described with TT-
MCTAG but they constitute a problem for any lo-
cal formalism and so far the nature of these phe-
nomena is not sufficiently well-understood.

Note that, in contrast to non-local MCTAG, in
TT-MCTAG the trees coming from the same in-
stance of a tuple in the grammar are not required
to be added at the same time. TT-MCTAGs share
this property of ‘non-simultaneity’ with other vec-
tor grammars such as Unordered Vector Gram-
mars (Cremers and Mayer, 1973) and Vector-
TAG (Rambow, 1994), V-TAG for short, and it

is crucial for the polynomial parsing algorithm.
The non-simultaneity seems to be an advantage
when using synchronous grammars to model the
syntax-semantics interface (Nesson and Shieber,
2008). The closest formalism to TT-MCTAG is
V-TAG. However, there are fundamental differ-
ences between the two. Firstly, they make a dif-
ferent use of dominance links: In V-TAG domi-
nance links relate different nodes in the trees of
a tree set from the grammar. They present domi-
nance requirements that constrain the derived tree.
In TT-MCTAG, there are no dominance links be-
tween nodes in elementary trees. Instead, the node
of a head tree in the derivation tree must domi-
nate all its arguments. Furthermore, even though
TT-MCTAG arguments can adjoin with a delay
to their head, their possible adjunction site is re-
stricted with respect to their head. As a result,
one obtains a slight degree of locality that can
be exploited for natural language phenomena that
are unbounded only in a limited domain. This is
proposed in (Lichte and Kallmeyer, 2008) where
the fact that substitution nodes block argument ad-
junction to higher heads is used to model the lim-
ited domain of scrambling in German. V-TAG
does not have any such notion of locality. Instead,
it uses explicit constraints, so-called integrity con-
straints, to establish islands.

3.2 An alternative characterization of
TT-MCTAG

The definition of TT-MCTAG in subsection 3.1 is
taken from (Lichte, 2007; Kallmeyer and Parmen-
tier, 2008). The condition (SN-TTL) on the TAG
derivation tree is formulated in terms of heads and
arguments belonging together, i.e., coming from
the same tuple instance. For our parsing algo-
rithm, we want to avoid grouping the instances
of elementary trees in a derivation tree into tu-
ple instances. In other words, we want to check
whether a TAG derivation tree is a valid TT-

997



MCTAG derivation tree without deciding, for ev-
ery occurrence of some argument β, which of the
h(β)-nodes represents its head. Therefore we pro-
pose to reformulate (SN-TTL).

For a node v in a derivation tree D, we write
Dv to represent the subtree of D rooted at v. For
γ ∈ (I ∪ A), we define Dom(v, γ) as the set of
nodes of Dv that are labeled by γ. Furthermore,
for an argument tree β ∈ A(G), we let π(v, β) =
|Dom(v, β)| − |Dom(v, h(β))|.

Lemma 1 Let G be a TT-MCTAG with underlying
TAG GT , and let D = 〈V,E, r〉 be a derivation
tree in GT that satisfies (MC). D satisfies (SN-
TTL) if and only if, for every v ∈ V and every
β ∈ A(G), the following conditions both hold.

(i) π(v, β) ≥ 0.

(ii) If π(v, β) > 0, then one of the following con-
ditions must be satisfied:

(a) Lab(v) = β and π(v, β) = 1;

(b) Lab(v) = β and π(v, β) > 1, and there
is some 〈v, vε〉 ∈ E with Lab(〈v, vε〉) =
ε and π(vε, β) + 1 = π(v, β);

(c) Lab(v) /∈ {β, h(β)} and there is some
〈v, vε〉 ∈ E with Lab(〈v, vε〉) = ε and
π(vε, β) = π(v, β);

(d) Lab(v) = h(β) and there is some
〈v, vε〉 ∈ E with Lab(〈v, vε〉) = ε and
π(v, β) ≤ π(vε, β) ≤ π(v, β) + 1.

Intuitively, condition (i) in lemma 1 captures the
fact that heads always dominate their arguments
in the derivation tree. Condition (ii)b states that,
if v is a β-node and if v is not the only ‘pend-
ing’ β-node in Dv, then all pending β-nodes in
Dv, except v itself, must be below the root adjoin-
ing node. Here pending means that the node is
not matched to a head-node within Dv. Condition
(ii)c treats the case in which there are pending β-
nodes in Dv for some node v whose label is neither
β nor h(β). Then the pending nodes must all be
below the root adjoining node. Finally, condition
(ii)d deals with the case of a h(β)-node v where,
besides the β-node that serves as an argument of
v, there are other pending β-nodes in Dv. These
other pending β-nodes must all be in Dvε , where
vε is the (unique) root adjoining node, if it exists.
The argument of v might as well be below vε, and
then the number of pending β-nodes in Dvε is the
number of pending nodes in Dv, incremented by
1, since the argument of v is not pending in Dv

but it is pending in Dvε . Otherwise, the argument
of v is a pending β-node below some other daugh-
ter of v. Then the number of pending β-nodes in
Dvε is the same as in Dv.

PROOF We first show that (SN-TTL) implies both
(i) and (ii).

Condition (i): Assume that there is a v ∈ V
and a β ∈ A(G) with π(v, β) < 0. Then for
some n and for pairwise different v1, . . . , vn with
〈v, vi〉 ∈ E

∗, Lab(vi) = h(β) (1 ≤ i ≤ n),
we cannot find pairwise different u1, . . . , un with
〈vi, ui〉 ∈ E

∗, Lab(ui) = β. This is in contradic-
tion with (SN-TTL). Consequently, condition (i)
must be satisfied.

Condition (ii): Assume β and v as in the state-
ment of the lemma, with π(v, β) > 0. Let
v1, . . . , vn be all the h(β)-nodes in D. There
is a bijection fβ from these nodes to n pairwise
distinct β-nodes in D, such that every pair vi,
fβ(vi) = ui satisfies the conditions in (SN-TTL).
Because of (MC), the nodes u1, . . . , un must be
all the β-nodes in D. There must be at least one vi
(1 ≤ i ≤ n) with 〈vi, v〉 ∈ E

+, 〈v, fβ(vi)〉 ∈ E
∗.

Then we have one of the following cases.
(a) ui = v and vi is the only h(β)-node dominat-
ing v with a corresponding β-node dominated by
v. In this case (ii)a holds.
(b) Lab(v) = β, i.e., 〈f−1

β
(v), v〉 ∈ E+ and there

are other nodes u ∈ Dom(v, β), u 6= v with
〈f−1

β
(u), v〉 ∈ E+. Then, with (SN-TTL), there

must be a vε with 〈v, vε〉 ∈ E, Lab(〈v, vε〉) = ε
and for all such nodes u, 〈vε, u〉 ∈ E

∗. Conse-
quently, (ii)b holds.
(c) Lab(v) /∈ {β, h(β)}. Then, as in (b), there
must be a vε with 〈v, vε〉 ∈ E, Lab(〈v, vε〉) = ε
and for all u ∈ Dom(v, β) with 〈f−1

β
(u), v〉 ∈

E+, 〈vε, u〉 ∈ E
∗. Consequently, (ii)c holds.

(d) Lab(v) = h(β). If fβ(v) is dominated by a vε
that is a daughter of v with Lab(〈v, vε〉) = ε, then
for all u ∈ Dom(v, β) with 〈f−1

β
(u), v〉 ∈ E+

we have 〈vε, u〉 ∈ E
∗. Consequently, π(vε, β) =

π(v, β) + 1. Alternatively, fβ(v) is dominated by
some other daughter v′ of v with Lab(〈v, v′〉) 6=
ε. In this case vε must still exist and, for all
u ∈ Dom(v, β) with u 6= fβ(v) and with
〈f−1

β
(u), v〉 ∈ E+, we have 〈vε, u〉 ∈ E

∗. Conse-
quently, π(vε, β) = π(v, β).

Now we show that (i) and (ii) imply (SN-TTL).
With (MC), the number of β-nodes and h(β)-
nodes in V are the same, for every β ∈ A(G). For
every β ∈ A(G), we construct a bijection fβ of the

998



same type as in the first part of the proof, and show
that (SN-TTL) is satisfied. To construct fβ, for ev-
ery v ∈ V we define sets Vβ,v ⊆ Dom(v, β) of β-
nodes vβ that have a matching head fβ(vβ) domi-
nating v. The definition satisfies |Vβ,v| = π(v, β).
For every v with v1, . . . , vn being all its daughters:
a) If Lab(v) = β, then (by (ii)) for every 1 ≤ j ≤
n with Lab(〈v, vj〉) 6= ε, Vβ,vj = ∅. If there is a
vi with Lab(〈v, vi〉) = ε, then Vβ,v = Vβ,vi ∪{v},
else Vβ,v = {v}.
b) If Lab(v) /∈ {β, h(β)}, then (by (ii)) Vβ,vj = ∅
for every 1 ≤ j ≤ n with Lab(〈v, vj〉) 6= ε. If
there is a vi with Lab(〈v, vi〉) = ε, then Vβ,v =
Vβ,vi , else Vβ,v = ∅.
c) If Lab(v) = h(β), then there must be some i,
1 ≤ i ≤ n, such that Vβ,vi 6= ∅. We need to
distinguish two cases. In the first case we have
Lab(〈v, vi〉) 6= ε, |Vβ,vi | = 1 and, for every
1 ≤ j ≤ n with j 6= i, either Vβ,vj = ∅ or
Lab(〈v, vj〉) = ε. In this case we define fβ(v) =
v′ for {v′} = Vβ,vi . In the second case we have
Lab(〈v, vi〉) = ε and, for every 1 ≤ j ≤ n with
j 6= i, Vβ,vj = ∅. In this case we pick an arbitrary
v′ ∈ Vβ,vi and let fβ(v) = v

′. In both cases we let
Vβ,v = (

⋃n
i=1 Vβ,vi) \ {fβ(v)}.

With this mapping, (SN-TTL) is satisfied when
choosing for each h(β)-node vi the β-node ui =
fβ(vi) as its corresponding node. �

4 Parsing algorithm

In this section we present a recognition algorithm
for TT-MCTAG working in polynomial time in the
size of the input string. The algorithm can be eas-
ily converted into a parsing algorithm. The ba-
sic idea is to use a parsing algorithm for TAG,
and impose on-the-fly additional restrictions on
the underlying derivation trees that are being con-
structed, in order to fulfill the definition of valid
TT-MCTAG derivation. To simplify the presenta-
tion, we assume without loss of generality that all
elementary trees in our grammars are binary trees.
The input string has the form w = a1 · · · an with
each ai ∈ VT and n ≥ 0 (n = 0 means w = ε).

4.1 TAG recognition

We start with the discussion of a baseline recogni-
tion algorithm for TAG, along the lines of (Vijay-
Shanker and Joshi, 1985). The algorithm is
specified by means of deduction rules, follow-
ing (Shieber et al., 1995), and can be implemented
using standard tabular techniques. Items have the

form [γ, pt, i, f1, f2, j] where γ ∈ I ∪ A, p is the
address of a node in γ, subscript t ∈ {⊤,⊥} speci-
fies whether substitution or adjunction has already
taken place (⊤) or not (⊥) at p, and 0 ≤ i ≤ f1 ≤
f2 ≤ j ≤ n are indices with i, j indicating the left
and right edges of the span recognized by p and
f1, f2 indicating the span of a gap in case a foot
node is dominated by p. We write f1 = f2 = − if
no gap is involved. For combining indices, we use
the operator f ′⊕f ′′ = f where f = f ′ if f ′′ = −,
f = f ′′ if f ′ = −, and f is undefined otherwise.
The deduction rules are shown in figure 4.

The algorithm walks bottom-up on the deriva-
tion tree. Rules (1) and (2) process leaf nodes
in elementary trees and require precondition
Lab(γ, p) = wi+1 and Lab(γ, p) = ε, respec-
tively. Rule (3) processes the foot node of aux-
iliary tree β ∈ A by guessing the portion of w
spanned by the gap. Note that we use p⊤ in the
consequent item in order to block adjunction at
foot nodes, as usually required in TAG.

We move up along nodes in an elementary
tree by means of rules (4) and (5), depending on
whether the current node has no sibling or has a
single sibling, respectively.

Rule (6) substitutes initial tree α at p in γ, un-
der the precondition α ∈ Sbst(γ, p). Similarly,
rule (7) adjoins auxiliary tree β at p in γ, under the
precondition β ∈ Adj (γ, p). Both these rules use
p⊤ in the consequent item in order to block mul-
tiple adjunction or substitution at p, as usually re-
quired in TAG. Rule (8) processes nodes at which
adjunction is not obligatory.

The algorithm recognizes w if and only if some
item [α, ε⊤, 0,−,−, n] can be inferred with α ∈ I
and Lab(α, ε) = S.

4.2 TT-MCTAG recognition

We now extend the recognition algorithm of fig-
ure 4 to TT-MCTAG. Let G be an input TT-
MCTAG. We assume that the tuples in T are num-
bered from 1 to |T |, and that the elementary trees
in each Γi are also numbered from 1 to |Γi|, with
the first element being the head. We then write γq,r
for the r-th elementary tree in the q-th tuple in T .

A t-counter is a ragged array T of integers with
primary index q ranging over {1, . . . , |T |} and
with secondary index r ranging over {1, . . . , |Γi|}.
We write T (q,r) to denote the t-counter with
T [q, r] = 1 and zero everywhere else. We also use
the sum and the difference of t-counters, which are

999



[γ, p⊥, i,−,−, i + 1]
(1)

[γ, p⊥, i,−,−, i]
(2)

[β, Ft(β)⊤, i, i, j, j]
(3)

[γ, (p · 1)⊤, i, f1, f2, j]
[γ, p⊥, i, f1, f2, j]

(4)

[γ, (p · 1)⊤, i, f1, f2, k]
[γ, (p · 2)⊤, k, f

′

1, f
′

2, j]
[γ, p⊥, i, f1 ⊕ f

′

1, f2 ⊕ f
′

2, j]
(5)

[α, ε⊤, i,−,−, j]
[γ, p⊤, i,−,−, j]

(6)

[β, ε⊤, i, f1, f2, j]
[γ, p⊥, f1, f

′

1, f
′

2, f2]
[γ, p⊤, i, f

′

1, f
′

2, j]
(7)

[γ, p⊥, i, f1, f2, j]
[γ, p⊤, i, f1, f2, j]

(8)

Figure 4: A baseline recognition algorithm for TAG. Rule preconditions and goal item are described in
the text.

[γq,r, p⊥, i,−,−, i + 1, T
(q,r)]

(9)

[γq,r, p⊥, i,−,−, i, T
(q,r)]

(10)

[γq,r,Ft(γq,r)⊤, i, i, j, j, T
(q,r)]

(11)

[γq,r, (p · 1)⊤, i, f1, f2, j, T ]
[γq,r, p⊥, i, f1, f2, j, T ]

(12)

[γq,r, (p · 1)⊤, i, f1, f2, k, T1]
[γq,r, (p · 2)⊤, k, f

′

1, f
′

2, j, T2]

[γq,r, p⊥, i, f1 ⊕ f
′

1, f2 ⊕ f
′

2, j, T1 + T2 − T
(q,r)]

(13)

[γq′,r′ , ε⊤, i,−,−, j, T
′]

[γq,r, p⊤, i,−,−, j, T
′ + T (q,r)]

(14)

[γq′,r′ , ε⊤, i, f1, f2, j, T
′]

[γq,r, p⊥, f1, f
′

1, f
′

2, f2, T ]
[γq,r, p⊤, i, f

′

1, f
′

2, j, T + T
′]

(15)

[γ, p⊥, i, f1, f2, j, T ]
[γ, p⊤, i, f1, f2, j, T ]

(16)

Figure 5: A recognition algorithm for TT-MCTAG. Rule preconditions are the same as for figure 4,
filtering conditions on rules are described in the text.

defined elementwise in the obvious way.
Let D be a derivation tree generated by the TAG

underlying G. We associate D with the t-counter
T such that T [q, r] equals the count of all occur-
rences of elementary tree γq,r appearing in D. In-
tuitively, we use t-counters to represent informa-
tion about TAG derivation trees that are relevant
to the licensing of such trees by the input TT-
MCTAG G.

We are now ready to present a recognizer based
on TT-MCTAG. To simplify the presentation, we
first discuss how to extend the algorithm of fig. 4
in order to compute t-counters, and will later spec-
ify how to apply TT-MCTAG filtering conditions
through such counters. The reader should however
keep in mind that the two processes are strictly
interleaved, with filtering conditions being tested
right after the construction of each new t-counter.

We use items of the form [γq,r, pt, i, f1, f2, j,
T ], where the first six components are defined as
in the case of TAG items, and the last component is
a t-counter associated with the constructed deriva-
tions. Our algorithm is specified in figure 5.

The simplest case is that of rules (12) and (16).
These rules do not alter the underlying derivation
tree, and thus the t-counter is simply copied from
the antecedent item to the consequent item.

Rules (9), (10) and (11) introduce γq,r as the

first elementary tree in the analysis (γq,r ∈ A in
case of rule (11)). Therefore we set the associated
t-counter to T (q,r).

In rule (14) we substitute initial tree γq′,r′ at
node p in γq,r. In terms of derivation structures,
we extend a derivation tree D′ rooted at node v′

with Lab(v′) = γq′,r′ to a new derivation tree D
with root node v, Lab(v) = γq,r. Node v has a sin-
gle child represented by the root of D′. Thus the
t-counter associated with D should be T ′ +T (q,r).

A slightly different operation needs to be per-
formed when applying rule (15). Here we have
a derivation tree D with root node v, Lab(v) =
γq,r and a derivation tree D

′ with root node v′,
Lab(v′) = γq′,r′ . When adjoining γq′,r′ into γq,r,
we need to add to the root of D a new child node,
represented by the root of D′. This means that
the t-counter associated with the consequent item
should be the sum of the t-counters associated with
D and D′.

Finally, rule (13) involves derivation trees D1
and D2, rooted at nodes v1 and v2, respectively.
Nodes v1 and v2 have the same label γq,r. The ap-
plication of the rule corresponds to the ‘merging’
of v1 and v2 into a new node v with label γq,r as
well, Node v inherits all of the children of v1 and
v2. In this case the t-counter associated with the
consequent item is T1 + T2 − T

(q,r). Here T (q,r)

1000



needs to be subtracted because the contribution of
tree γq,r is accounted for in both v1 and v2.

We can now discuss the filtering conditions that
need to be applied when using the above deduc-
tion rules. We start by observing that the algo-
rithm in figure 5 might not even stop if there is an
infinite set of derivation trees for the input string
w = a1 · · · an in the underlying TAG GT . This
is because each derivation can have a distinct t-
counter. However, the definition of TT-MCTAG
imposes that the head tree of each tuple contains
at least one lexical element. Together with con-
dition (MC), this implies that no more than n tu-
ple instances can occur in a derivation tree for w
according to G. To test for such a condition, we
introduce a norm for t-counters

||T ||m =

|T |∑

q=1

max
|Γq|
r=1 T [q, r] .

We then impose ||T ||m ≤ n for each t-counter con-
structed by our deduction rule, and block the cor-
responding derivation if this is not satisfied.

We also need to test conditions (i) and (ii) from
lemma 1. Since these conditions apply to nodes
of the derivation tree, this testing is done at each
deduction rule in which a consequent item may be
constructed for a node ε⊤, that is, rules (14), (15)
and (16). We introduce two specialized predicates

F≤(T ) ≡ ∀(q, r) : T [q, 1] ≤ T [q, r] ;

F=(T ) ≡ ∀(q, r) : T [q, 1] = T [q, r] .

We then test F≤(T ), which amounts to testing
condition (i) for each argument tree in A(G).
Furthermore, if at some rule we have F≤(T ) ∧
¬F=(T ), then we need to test for condition (ii).
To do this, we consider each argument tree γq,r,
r 6= 1, and compare the elementary tree γq,r in the
consequent item of the current rule with γq,r and
h(γq,r) = γq,1, to select the appropriate subcondi-
tion of (ii).

As an example, assume that we are applying
rule (15) as in figure 5, with p = ε. Let Tc =
T + T ′ be the t-counter associated with the con-
sequent item. When we come to process some ar-
gument tree γq,r such that Tc[q, r] − Tc[q, 1] > 0
and γq,r 6∈ {γq,r, γq,1}, we need to test (ii)c. This
is done by requiring

T ′[q, r]− T ′[q, 1] = Tc[q, r]− Tc[q, 1].

If we are instead applying rule (16) with p = ε
and T [q, r]− T [q, 1] > 0, then we test (ii)a, since

there is no adjunction at the root node, by requir-
ing γq,r = γq,r and T [q, r]− T [q, 1] = 1.

We block the current derivation whenever the
conditions in lemma 1 are not satisfied.

The algorithm recognizes w if and only if some
item [γq,1, ε⊤, 0,−,−, n, T ] can be inferred sat-
isfying γq,1 ∈ I , Lab(γq,1, ε) = S and F=(T ).
The correctness immediately follows from the cor-
rectness of the underlying TAG parser and from
lemma 1.

Finally, we turn to the computational analysis
of the algorithm. We assume a tabular implemen-
tation of the process of item inference using our
deduction rules. Our algorithm clearly stops after
some finite amount of time, because of the filtering
condition ||T ||m ≤ n. We then need to derive an
upper bound on the number of applications of de-
duction rules. To do this, we use an argument that
is rather standard in the tabular parsing literature.
The number of t-counters satisfying ||T ||m ≤ n

is O(ncG), with cG =
∑|T |

i=1 |Γi|. Since all of
the other components in an item are bounded by
O(n4), there are polynomially (in n) many items
that can be constructed for an input w. It is not dif-
ficult to see that each individual item can be con-
structed by a number of rule applications bounded
by a polynomial as well. Therefore, the total num-
ber of applications of our deduction rules is also
bounded by some polynomial in n. We thus con-
clude that the languages generated by the class TT-
MCTAG are all included in PTIME.

5 Conclusion and open problems

We have shown in this paper that the class of lan-
guages generated by TT-MCTAG is included in
PTIME, by characterizing the definition of TT-
MCTAG through some conditions that can be
tested locally. PTIME is one of the required
properties in the definition of the class of Mildly
Context-Sensitive (MCS) formalisms (Joshi et al.,
1991). In order to settle membership in MCS for
TT-MCTAG, what is still missing is the constant-
growth property or, more generally, the semilin-
earity property.

Acknowledgments

The work of the first author has been sup-
ported by the DFG within the Emmy-Noether
Program. The second author has been partially
supported by MIUR under project PRIN No.
2007TJNZRE 002.

1001



References

Tilman Becker, Aravind K. Joshi, and Owen Rambow.
1991. Long-distance scrambling and tree adjoining
grammars. In Proceedings of ACL-Europe.

Tilman Becker, Owen Rambow, and Michael Niv.
1992. The Derivationel Generative Power of Formal
Systems or Scrambling is Beyond LCFRS. Tech-
nical Report IRCS-92-38, Institute for Research in
Cognitive Science, University of Pennsylvania.

Lucas Champollion. 2007. Lexicalized non-local MC-
TAG with dominance links is NP-complete. In Ger-
ald Penn and Ed Stabler, editors, Proceedings of
Mathematics of Language (MOL) 10, CSLI On-Line
Publications.

Joan Chen-Main and Aravind Joshi. 2007. Some
observations on a graphical model-theoretical ap-
proach and generative models. In Model Theoretic
Syntax at 10. Workshop, ESSLLI 2007, Dublin, Ire-
land.

Armin B. Cremers and Otto Mayer. 1973. On matrix
languages. Information and Control, 23:86–96.

Aravind K. Joshi and Yves Schabes. 1997. Tree-
Adjoning Grammars. In G. Rozenberg and A. Salo-
maa, editors, Handbook of Formal Languages, pages
69–123. Springer, Berlin.

Aravind K. Joshi, Leon S. Levy, and Masako Taka-
hashi. 1975. Tree Adjunct Grammars. Journal of
Computer and System Science, 10:136–163.

A. Joshi, K. Vijay-Shanker, and D. Weir. 1991. The
convergence of mildly context-sensitive grammati-
cal formalisms. In P. Sells, S. Shieber, and T. Wa-
sow, editors, Foundational Issues in Natural Lan-
guage Processing. MIT Press, Cambridge MA.

Aravind K. Joshi. 1985. Tree adjoining grammars:
How much contextsensitivity is required ro provide
reasonable structural descriptions? In D. Dowty,
L. Karttunen, and A. Zwicky, editors, Natural Lan-
guage Parsing, pages 206–250. Cambridge Univer-
sity Press.

Laura Kallmeyer and Yannick Parmentier. 2008. On
the relation between Multicomponent Tree Adjoin-
ing Grammars with Tree Tuples (TT-MCTAG) and
Range Concatenation Grammars (RCG). In Carlos
Martı́n-Vide, Friedrich Otto, and Henning Fernaus,
editors, Language and Automata Theory and Ap-
plications. Second International Conference, LATA
2008, number 5196 in Lecture Notes in Computer
Science, pages 263–274. Springer-Verlag, Heidel-
berg Berlin.

Laura Kallmeyer. 2005. Tree-local multicomponent
tree adjoining grammars with shared nodes. Com-
putational Linguistics, 31(2):187–225.

Timm Lichte and Laura Kallmeyer. 2008. Factorizing
Complementation in a TT-MCTAG for German. In

Proceedings of the Ninth International Workshop on
Tree Adjoining Grammars and Related Formalisms
(TAG+9), pages 57–64, Tübingen, June.

Timm Lichte. 2007. An MCTAG with Tuples for Co-
herent Constructions in German. In Proceedings
of the 12th Conference on Formal Grammar 2007,
Dublin, Ireland.

Rebecca Nesson and Stuart Shieber. 2008. Syn-
chronous Vector TAG for Syntax and Semantics:
Control Verbs, Relative Clauses, and Inverse Link-
ing. In Proceedings of the Ninth International Work-
shop on Tree Adjoining Grammars and Related For-
malisms (TAG+9), Tübingen, June.

Owen Rambow and Giorgio Satta. 1992. Formal prop-
erties of non-locality. In Proceedings of 1st Interna-
tional Workshop on Tree Adjoining Grammars.

Owen Rambow and Giorgio Satta. 1994. A rewrit-
ing system for free word order syntax that is non-
local and mildly context sensitive. In C. Martı́n-
Vide, editor, Current Issues in Mathematical Lin-
guistics, North-Holland Linguistic series, Volume
56. Elsevier-North Holland, Amsterdam.

Owen Rambow, K. Vijay-shanker, and David Weir.
1995. Parsing d-Ttree grammars. In Proceedings of
the Fourth International Workshop on Parsing Tech-
nologies, Prague, pages 252–259.

Owen Rambow. 1994. Formal and Computational
Aspects of Natural Language Syntax. Ph.D. thesis,
University of Pennsylvania.

Giorgio Satta. 1995. The membership problem for un-
ordered vector languages. In Developments in Lan-
guage Theory, pages 267–275.

Stuart M. Shieber, Yves Schabes, and Fernando C. N.
Pereira. 1995. Principles and Implementation of
Deductive Parsing. Journal of Logic Programming,
24(1&2):3–36.

Anders Søgaard, Timm Lichte, and Wolfgang Maier.
2007. The complexity of linguistically motivated
extensions of tree-adjoining grammar. In Recent
Advances in Natural Language Processing 2007,
Borovets, Bulgaria.

K. Vijay-Shanker and Aravind K. Joshi. 1985. Some
computational properties of Tree Adjoining Gram-
mars. In Proceedings of the 23rd Annual Meeting
of the Association for Computational Linguistics,
pages 82–93.

K. Vijay-Shanker, D. J. Weir, and A. K. Joshi. 1987.
Characterizing structural descriptions produced by
various grammatical formalisms. In 25th Meet-
ing of the Association for Computational Linguistics
(ACL’87).

David J. Weir. 1988. Characterizing mildly context-
sensitive grammar formalisms. Ph.D. thesis, Uni-
versity of Pennsylvania.

1002


